/*!
 * accordion v3.0.0
 * https://github.com/alexspirgel/accordion
 */
var Accordion;(()=>{var t={683:(t,e,r)=>{const o=r(605);t.exports=function(t){return"object"==typeof t&&null!==t&&1===t.nodeType&&!o(t)}},605:t=>{t.exports=function(t){if("object"!=typeof t||null===t||"[object Object]"!==Object.prototype.toString.call(t))return!1;if(null===Object.getPrototypeOf(t))return!0;let e=t;for(;null!==Object.getPrototypeOf(e);)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e}},364:(t,e,r)=>{const o=r(683);t.exports=function t(e,r=new Set){if(Array.isArray(e)||e instanceof NodeList)for(let o of e)t(o,r);else if("string"==typeof e){t(document.querySelectorAll(e),r)}else o(e)&&r.add(e);return Array.from(r)}},662:(t,e,r)=>{const o=r(160),s=r(768),n=r(683),i=r(364);t.exports=class Accordion{static get accordions(){return Array.isArray(this._accordions)||(this._accordions=[]),this._accordions}static set accordions(t){if(!Array.isArray(t))throw new Error("'accordions' must be an array.");if(!t.every(this.isAccordion))throw new Error("'accordions' must only contain instances of Accordion.");this._accordions=t}static isAccordion(t){return t instanceof this}static getAccordion(t){if(this.isAccordion(t))return this.accordions.find((e=>e===t))}static addAccordion(t){if(!this.isAccordion(t))throw new Error("'accordion' must be an accordion.");this.getAccordion(t)||this.accordions.push(t)}static removeAccordion(t){if(this.getAccordion(t)){const t=this.accordions.indexOf(t);t>=0&&this.accordions.splice(t,1)}}static getAccordionObject(t){for(const e of this.accordions)for(const r of e.bundles){if(t===r.element)return r;for(const e of r.items){if(t===e.element)return e;if(e.trigger&&t===e.trigger.element)return e.trigger;if(e.content){if(t===e.content.element)return e.content;if(e.content.contentInner&&t===e.content.contentInner.element)return e.content.contentInner}}}}static removeExistingAccordionObjectElementsFromArray(t){if(!Array.isArray(t))throw new Error("'elements' must be an array.");return t=t.filter((t=>{if(!this.getAccordionObject(t))return!0}))}static getNestedBundles(t){if(!n(t))throw new Error("'element' must be an element.");const e=[];for(const r of this.accordions)for(const o of r.bundles)n(o.element)&&t.contains(o.element)&&t!==o.element&&e.push(o);return e}static isElementContainedBy(t,e=[],r="and"){if(!n(t))throw new Error("'element' must be an element.");const o=i(e);if("string"!=typeof r)throw new Error("'operator' must be a string.");if("and"!==(r=r.toLowerCase())&&"or"!==r)throw new Error("'operator' must be 'and' or 'or'.");let s=!1;for(const e of o)if(e.contains(t)&&e!==t){if(s=!0,"or"===r)break}else if(s=!1,"and"===r)break;return s}static get defaultOptions(){return{selectors:{bundle:void 0,item:void 0,trigger:void 0,content:void 0,contentInner:void 0},defaultOpenItems:void 0,accessibilityWarnings:!0,closeNestedItems:!1,multipleOpenItems:!0,openAnchoredItems:!0,dataAttributes:{elementType:"data-accordion",itemState:"data-accordion-state"},debug:!1}}static get optionsValidation(){const t=({value:t,pathId:e})=>{if("string"!=typeof t&&void 0!==t)throw new Error(`'${e}' must be a string or undefined.`)},e=({value:t,pathId:e})=>{if("boolean"!=typeof t)throw new Error(`'${e}' must be a boolean.`)},r=({value:t,pathId:e})=>{if("string"!=typeof t)throw new Error(`'${e}' must be a string.`)};return{selectors:({value:t,pathId:e})=>{if(("object"!=typeof t||null===t)&&void 0!==t)throw new Error(`'${e}' must be an object or undefined.`)},"selectors.bundle":t,"selectors.item":t,"selectors.trigger":t,"selectors.content":t,"selectors.contentInner":t,defaultOpenItems:({value:t,pathId:e})=>{if("number"!=typeof t&&"string"!=typeof t&&("object"!=typeof t||null===t)&&void 0!==t)throw new Error(`'${e}' must be an number (zero indexed), selector string, element reference, or undefined.`)},accessibilityWarnings:e,closeNestedItems:e,multipleOpenItems:e,openAnchoredItems:e,dataAttributes:({value:t,pathId:e})=>{if("object"!=typeof t||null===t)throw new Error(`'${e}' must be an object.`)},"dataAttributes.elementType":r,"dataAttributes.itemState":r,debug:e}}constructor(t={}){if(this.options=new o(this.constructor.defaultOptions,this.constructor.optionsValidation),this.options.merge(t),this.constructor.addAccordion(this),!this.initialized){const t=this.options.get("selectors.bundle"),e=this.options.get("selectors.item"),r=this.options.get("selectors.trigger"),o=this.options.get("selectors.content"),s=this.options.get("selectors.contentInner"),i=[],c=[];if(t){let e=Array.from(document.querySelectorAll(t));e=this.constructor.removeExistingAccordionObjectElementsFromArray(e);for(const t of e){const e=this.addBundle(t);i.push(e)}}if(e)for(const t of i){let r=Array.from(t.element.querySelectorAll(e));r=this.constructor.removeExistingAccordionObjectElementsFromArray(r);const o=this.constructor.getNestedBundles(t.element),s=[];for(const t of o)n(t.element)&&s.push(t.element);r=r.filter((t=>!this.constructor.isElementContainedBy(t,s,"or")));for(const e of r){const r=t.addItem(e);c.push(r)}}if(r)for(const t of c);if(o)for(const t of c);if(s)for(const t of c);this.initialized=!0}this.log(this)}get bundles(){return Array.isArray(this._bundles)||(this._bundles=[]),this._bundles}set bundles(t){if(!Array.isArray(t))throw new Error("'bundles' must be an array.");if(!t.every(s.isBundle))throw new Error("'bundles' must only contain instances of Bundle.");this._bundles=t}addBundle(t){const e=new s(this,t);return this.bundles.push(e),e}removeBundle(t){const e=this.bundles.indexOf(t);if(e>=0)return this.bundles.splice(e,1),t}destroy(){for(const t of this.bundles)t.destroy();this.constructor.removeAccordion(this)}log(...t){this.options.get("debug")&&console.log("Accordion:",...t)}}},768:(t,e,r)=>{const o=r(683),s=r(87);t.exports=class Bundle{static isBundle(t){return t instanceof this}constructor(t,e){this.accordion=t,this.element=e}get options(){if(this.accordion)return this.accordion.options}get element(){return this._element}set element(t){if(!o(t))throw new Error("'element' must be an element.");if(this.accordion.constructor.getAccordionObject(t))throw new Error("'element' is already used in an accordion.");t.setAttribute(this.accordion.options.get("dataAttributes.elementType"),"bundle"),this._unsetElement(),this._element=t}_unsetElement(){o(this.element)&&this.element.removeAttribute(this.accordion.options.get("dataAttributes.elementType")),this._element=void 0}get items(){return Array.isArray(this._items)||(this._items=[]),this._items}set items(t){if(!Array.isArray(t))throw new Error("'items' must be an array.");if(!t.every(s.isItem))throw new Error("'items' must only contain instances of Item.");this._items=t}addItem(t){const e=new s(this,t);this.items.push(e)}removeItem(t){if(s.isItem(t)){const e=this.items.indexOf(t);e>=0&&this.items.splice(e,1)}}destroy(){for(const t of this.items)t.destroy();this._unsetElement(),this.accordion.removeBundle(this)}}},87:(t,e,r)=>{const o=r(683);t.exports=class Item{static isItem(t){return t instanceof this}constructor(t,e){this.bundle=t,this.element=e}get accordion(){if(this.bundle)return this.bundle.accordion}get options(){if(this.accordion)return this.accordion.options}get element(){return this._element}set element(t){if(!o(t))throw new Error("'element' must be an element.");if(this.accordion.constructor.getAccordionObject(t))throw new Error("'element' is already used in another accordion.");t.setAttribute(this.accordion.options.get("dataAttributes.elementType"),"item"),this._unsetElement(),this._element=t}_unsetElement(t){o(this.element)&&t.removeAttribute(this.accordion.options.get("dataAttributes.elementType")),this._element=void 0}destroy(){this._unsetElement(),this.bundle.removeItem(this)}}},160:t=>{t.exports=class ObjectManager{static isString(t){return"string"==typeof t}static isObject(t){return"object"==typeof t&&null!==t}static normalizePath(t){if("string"==typeof t&&(t=t.split(".")),Array.isArray(t)&&t.every(this.isString))return t;throw new Error("'path' must be either a string or an array of strings.")}static getPathId(t){return(t=this.normalizePath(t)).join(".")}static getObjectProperty(t,e,r){let o=t;if((e=this.normalizePath(e)).length>0)for(const t of e){if(!this.isObject(o)){o=void 0;break}o=o[t]}return void 0!==o?o:r}static setObjectProperty(t,e,r){let o=!1;if((e=this.normalizePath(e)).length>0){const s=e[e.length-1];for(const n of e){if(!this.isObject(t))break;n===s?(t[n]=r,o=!0):t=t[n]}}return o}static get eventListenerTypes(){return["get","set","change"]}static validateEventListenerType(t){if(!this.eventListenerTypes.includes(t))throw new Error(`type '${t}' is not a valid type.`)}static merge(t,e=[],r){if(Array.isArray(r)){t.set(e,[]);for(let o=0;o<r.length;o++)e.push(o),t.set(e,this.merge(t,e,r[o])),e.splice(-1)}else if(this.isObject(r)){this.isObject(this.getObjectProperty(t.object,e))||t.set(e,{});for(let o in r)e.push(o),t.set(e,this.merge(t,e,r[o])),e.splice(-1)}else void 0!==r&&t.set(e,r);return this.getObjectProperty(t.object,e)}constructor(t,e){this.validation=e,this.object=t}get object(){return this._object}set object(t){this._object={},this.merge(t)}get validation(){return this._validation}set validation(t){if(!this.constructor.isObject(t)&&void 0!==t)throw new Error("'validation' must be an object or undefined.");this._validation=t}validatePropertyValue(t,e){t=this.constructor.normalizePath(t);const r=this.constructor.getPathId(t);this.constructor.isObject(this.validation)&&"function"==typeof this.validation[r]&&this.validation[r]({value:e,path:t,pathId:r,object:this.object})}get(t,e){t=this.constructor.normalizePath(t);const r=this.constructor.getObjectProperty(this.object,t,e);return this.dispatchEvent(t,"get",{object:this.object,path:t,type:"get",value:r}),r}set(t,e){this.validatePropertyValue(t,e),t=this.constructor.normalizePath(t);const r=this.constructor.getObjectProperty(this.object,t),o=this.constructor.setObjectProperty(this.object,t,e);return o&&(this.dispatchEvent(t,"set",{object:this.object,path:t,type:"set",value:e,previousValue:r}),e!==r&&this.dispatchEvent(t,"change",{object:this.object,path:t,type:"change",value:e,previousValue:r})),o}merge(t){if(!this.constructor.isObject(t))throw new Error("'object' must be an object.");this.constructor.merge(this,[],t)}get eventListeners(){return this.constructor.isObject(this._eventListeners)||(this._eventListeners={}),this._eventListeners}addEventListener(t,e,r){const o=this.constructor.getPathId(t);if(this.constructor.validateEventListenerType(e),"function"!=typeof r)throw new Error("callback must be a function.");this.eventListeners[o]||(this.eventListeners[o]=[]);const s={type:e,callback:r};this.eventListeners[o].push(s)}dispatchEvent(t,e,r){t=this.constructor.normalizePath(t);const o=this.constructor.getPathId(t);if(this.constructor.validateEventListenerType(e),Array.isArray(this.eventListeners[o])){void 0===r&&(r={object:this.object,path:t,type:e});for(const t of this.eventListeners[o])t.type===e&&t.callback(r)}}removeEventListener(t,e,r){const o=this.constructor.getPathId(t);if(Array.isArray(this.eventListeners[o]))for(let t=0;t<this.eventListeners[o].length;t++){const s=this.eventListeners[o][t];e===s.type&&r===s.callback&&this.eventListeners[o].splice(t,1)}}}}},e={};var r=function r(o){var s=e[o];if(void 0!==s)return s.exports;var n=e[o]={exports:{}};return t[o](n,n.exports,r),n.exports}(662);Accordion=r})();