var AceAccordion =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/ace-accordion.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@alexspirgel/extend/extend.js":
/*!****************************************************!*\
  !*** ./node_modules/@alexspirgel/extend/extend.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * extend v2.0.3\r\n * https://github.com/alexspirgel/extend\r\n */\r\n\r\n/**\r\n * Extends an object with another object(s).\r\n *\r\n * @param {array} objects - Array of objects containing the resulting object and the objects to merge into it.\r\n * @param {boolean} [deep] - Optional flag to enable or disable recursive merge.\r\n *\r\n * @returns {object} The object that has been extended.\r\n */\r\n\r\nconst extend = (objects, deep) => {\r\n\r\n\t/**\r\n\t * Extends an object with another object.\r\n\t *\r\n\t * @param {object} target_object - The target object to be merged into.\r\n\t * @param {object} merge_object - The object to merge into the target object.\r\n\t * @param {boolean} [deep] - Optional flag to enable or disable recursive merge.\r\n\t *\r\n\t * @returns {object} The object that has been extended.\r\n\t */\r\n\r\n\tconst extendObject = (target_object, merge_object, deep) => {\r\n\t\t// For each property in the merge_object.\r\n\t\tfor (let property in merge_object) {\r\n\t\t\t// If the merge_object value is an object, is not null, and the deep flag is true.\r\n\t\t\tif (typeof merge_object[property] === 'object' && merge_object[property] !== null && deep) {\r\n\t\t\t\t// If the merge_object value is a special case.\r\n\t\t\t\tif (merge_object[property] instanceof Window || merge_object[property] instanceof HTMLDocument || merge_object[property] instanceof Element) {\r\n\t\t\t\t\t// Set the target_object property value equal to the merge_object property value.\r\n\t\t\t\t\ttarget_object[property] = merge_object[property];\r\n\t\t\t\t\t// Continue past the normal deep object handling.\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t// If the merge_object value is an array.\r\n\t\t\t\tif (Array.isArray(merge_object[property]) || merge_object[property] instanceof NodeList) {\r\n\t\t\t\t\tif (merge_object[property] instanceof NodeList) {\r\n\t\t\t\t\t\tmerge_object[property] = Array.from(merge_object[property]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Set the target_object value equal to an empty array (arrays are replaced, not merged).\r\n\t\t\t\t\ttarget_object[property] = [];\r\n\t\t\t\t}\r\n\t\t\t\t// If the target_object value is not an object or if it is null.\r\n\t\t\t\telse if (typeof target_object[property] !== 'object' || target_object[property] === null) {\r\n\t\t\t\t\t// Set the target_object value equal to an empty object.\r\n\t\t\t\t\ttarget_object[property] = {};\r\n\t\t\t\t}\r\n\t\t\t\t// Call the extendObject function recursively.\r\n\t\t\t\textendObject(target_object[property], merge_object[property], deep);\r\n\t\t\t\t// Continue to the next property, skipping the normal value assignment.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// Set the target_object property value equal to the merge_object property value (primitive values or shallow calls).\r\n\t\t\ttarget_object[property] = merge_object[property];\r\n\t\t}\r\n\t\t// Return the target_object.\r\n\t\treturn target_object;\r\n\t}; // End function extendObject.\r\n\r\n\t// If objects length is greater than 1.\r\n\tif (objects.length > 1) {\r\n\t\t// For each object in objects (skipping the first object).\r\n\t\tfor (let object = 1; object < objects.length; object++) {\r\n\t\t\t// If the current loop item is an object and not null.\r\n\t\t\tif (typeof objects[object] === 'object' && objects[object] !== null) {\r\n\t\t\t\t// Extend the first object with the current loop object.\r\n\t\t\t\textendObject(objects[0], objects[object], deep);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Return the first object in the array.\r\n\treturn objects[0];\r\n\r\n}; // End function extend.\r\n\r\n// If script is being required as a node module.\r\nif (typeof module !== 'undefined' && module.exports) {\r\n\t// Export the extend function.\r\n\tmodule.exports = extend;\r\n}\n\n//# sourceURL=webpack://AceAccordion/./node_modules/@alexspirgel/extend/extend.js?");

/***/ }),

/***/ "./src/js/accordion.js":
/*!*****************************!*\
  !*** ./src/js/accordion.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Require Item class.\r\nconst Item = __webpack_require__(/*! ./item.js */ \"./src/js/item.js\");\r\n\r\n/**\r\n * Defines an Accordion.\r\n */\r\n\r\nconst Accordion = class {\r\n\r\n\t/**\r\n\t * Defines constant class variables.\r\n\t */\r\n\r\n\tstatic get constants() {\r\n\t\tconst id_attribute = 'data-ace-accordion-id';\r\n\t\tconst global_selector = '[' + id_attribute + ']';\r\n\t\treturn {\r\n\t\t\tglobal_selector: global_selector,\r\n\t\t\tid_attribute: id_attribute,\r\n\t\t\titem_instances_property: 'items'\r\n\t\t};\r\n\t} // End method: static get constants\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget options() {\r\n\t\t// Return options from the wrapper AceAccordion object.\r\n\t\treturn this.wrapper_ace_accordion.options;\r\n\t} // End method: get options\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget parent_accordion() {\r\n\t\t// Get the parent node.\r\n\t\t// We do this because Element.closest can match with itself.\r\n\t\tconst parent_node = this.element.parentNode;\r\n\t\t// Get the closest parent accordion.\r\n\t\tlet parent_accordion = parent_node.closest('[' + this.constructor.constants.id_attribute + ']');\r\n\t\t// If a parent accordion exists.\r\n\t\tif (parent_accordion) {\r\n\t\t\t// Set parent_accordion equal to the ace object.\r\n\t\t\tparent_accordion = parent_accordion.ace_object;\r\n\t\t}\r\n\t\t// Return the parent accordion object, or null.\r\n\t\treturn parent_accordion;\r\n\t} // End method: get parent_accordion\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget item_elements() {\r\n\t\t// Get item elements and convert the result into an array.\r\n\t\treturn Array.from(this.element.querySelectorAll(this.selector + ' > ' + this.options.selectors.item));\r\n\t} // End method: get item_elements\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\taddItem(item_element) {\r\n\r\n\t\t// If the callback option value is a function.\r\n\t\tif (typeof this.options.callbacks.item.initialize.before === 'function') {\r\n\t\t\t// Call the callback function, passing null as this and the item element as an argument.\r\n\t\t\tthis.options.callbacks.item.initialize.before.call(null, item_element);\r\n\t\t}\r\n\r\n\t\t// Get the next instance id.\r\n\t\t// The current instance count equals the next instance id because the id is zero indexed.\r\n\t\tconst item_id = this.item_count;\r\n\r\n\t\t// Create a new item.\r\n\t\tconst item = new Item(this, item_id, item_element);\r\n\r\n\t\t//\r\n\t\tif (item) {\r\n\t\t\t// Call the static function to add the instance.\r\n\t\t\tthis.wrapper_ace_accordion.constructor.addInstance(this, 'item_count', 'items', item);\r\n\t\t}\r\n\r\n\t\t// If the callback option value is a function.\r\n\t\tif (typeof this.options.callbacks.item.initialize.after === 'function') {\r\n\t\t\t// Call the callback function, passing the item object as this and the item element as an argument.\r\n\t\t\tthis.options.callbacks.item.initialize.after.call(item, item_element);\r\n\t\t}\r\n\r\n\t} // End: method: addItem\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tconstructor(ace_accordion, accordion_id, accordion_element) {\r\n\r\n\t\t// Set a reference to the wrapper instance.\r\n\t\tthis.wrapper_ace_accordion = ace_accordion;\r\n\r\n\t\t// Add the accordion element reference.\r\n\t\tthis.element = accordion_element;\r\n\r\n\t\t// Add the this instance object reference to the element.\r\n\t\tthis.element.ace_object = this;\r\n\r\n\t\t// Add this instance to the wrapper instance and set the instance id.\r\n\t\tthis.id = accordion_id;\r\n\r\n\t\t// Set the AceAccordion class instance id data attribute.\r\n\t\tthis.element.setAttribute(this.wrapper_ace_accordion.constructor.constants.id_attribute, this.wrapper_ace_accordion.id);\r\n\t\t// Set the Accordion class instance id data attribute.\r\n\t\tthis.element.setAttribute(this.constructor.constants.id_attribute, this.id);\r\n\r\n\t\t// Create a unique selector for this Accordion.\r\n\t\tthis.selector = this.wrapper_ace_accordion.selector + '[' + this.constructor.constants.id_attribute + '=\"' + this.id + '\"]';\r\n\r\n\t\t//\r\n\t\tthis.item_count = 0;\r\n\t\t//\r\n\t\tthis.items = {};\r\n\r\n\t\t// If there is at least one item.\r\n\t\tif (this.item_elements.length > 0) {\r\n\t\t\t// For each item element.\r\n\t\t\tfor(let index = 0; index < this.item_elements.length; index++) {\r\n\t\t\t\t// Initialize an item.\r\n\t\t\t\tthis.addItem(this.item_elements[index]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// If there are no items in this accordion.\r\n\t\telse {\r\n\t\t\t// If debug is true.\r\n\t\t\tif (this.options.debug) {\r\n\t\t\t\t// Send a warning to the console.\r\n\t\t\t\tconsole.warn(this.constructor.name + \": No items found using selector: '\" + this.options.selectors.item + \"'\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Return this instance.\r\n\t\treturn this;\r\n\r\n\t} // End method: constructor\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tdestroy() {\r\n\t\t//\r\n\t} // End method: destroy\r\n\r\n}; // End class: Accordion\r\n\r\n// Export the Accordion class.\r\nmodule.exports = Accordion;\n\n//# sourceURL=webpack://AceAccordion/./src/js/accordion.js?");

/***/ }),

/***/ "./src/js/ace-accordion.js":
/*!*********************************!*\
  !*** ./src/js/ace-accordion.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\r\n * AceAccordion v1.0.0\r\n * https://github.com/alexspirgel/accordion\r\n */\r\n\r\n// Require extend function.\r\nconst extend = __webpack_require__(/*! @alexspirgel/extend */ \"./node_modules/@alexspirgel/extend/extend.js\");\r\n// Require Accordion class.\r\nconst Accordion = __webpack_require__(/*! ./accordion.js */ \"./src/js/accordion.js\");\r\n\r\n/**\r\n * Defines an Ace Accordion (a handling wrapper for the Accordion Class).\r\n */\r\n\r\nconst AceAccordion = class {\r\n\r\n\t/**\r\n\t * Defines the default set of options.\r\n\t */\r\n\r\n\tstatic get options_default() {\r\n\t\treturn {\r\n\t\t\tselectors: {\r\n\t\t\t\taccordion: '.accordion', // {string} Custom accordion element selector.\r\n\t\t\t\titem: '.accordion__item', // {string} Custom item element selector.\r\n\t\t\t\theading: '.accordion__item__heading', // {string} Custom heading element selector.\r\n\t\t\t\tcontent: '.accordion__item__content', // {string} Custom content element selector.\r\n\t\t\t\tcontent_inner: '.accordion__item__content__inner' // {string} Custom content inner element selector.\r\n\t\t\t},\r\n\t\t\t// accessibility_warnings: true, // {boolean} Log detected accessibility issues as warnings.\r\n\t\t\tclose_nested_items: false, // {boolean} Close immediate nested items. Can chain down levels depending on nested options.\r\n\t\t\t// custom_css: false, // {boolean} When true, prevent the script from adding it's own styles (not recommended).\r\n\t\t\tdefault_open_items: null, // {number|string|object|array} Initializes item(s) to default open by default.\r\n\t\t\theading_trigger_selector: null, // {string} Selector (scoped within heading) to trigger item open/close, rather than entire heading element.\r\n\t\t\tmultiple_open_items: true, // {boolean} When true, allow multiple items to be open at the same time.\r\n\t\t\t// open_anchored_items: false, // {boolean} When anchored to an accordion item, open it.\r\n\t\t\ttrigger_on_hover: false, // {boolean} Trigger open/close based on if the cursor is hovered over the item.\r\n\t\t\tcallbacks: {\r\n\t\t\t\taccordion: {\r\n\t\t\t\t\tinitialize: {\r\n\t\t\t\t\t\tbefore: null,\r\n\t\t\t\t\t\tafter: null\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\titem: {\r\n\t\t\t\t\tinitialize: {\r\n\t\t\t\t\t\tbefore: null,\r\n\t\t\t\t\t\tafter: null\r\n\t\t\t\t\t},\r\n\t\t\t\t\topen: {\r\n\t\t\t\t\t\t// before: null,\r\n\t\t\t\t\t\t// after: null\r\n\t\t\t\t\t},\r\n\t\t\t\t\tclose: {\r\n\t\t\t\t\t\t// before: null,\r\n\t\t\t\t\t\t// after: null\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tdebug: false // Log helpful messages to the console for development.\r\n\t\t};\r\n\t} // End method: static get options_default\r\n\r\n\t/**\r\n\t * Defines constant class variables.\r\n\t */\r\n\r\n\tstatic get constants() {\r\n\t\treturn {\r\n\t\t\tid_attribute: 'data-ace-instance-id'\r\n\t\t};\r\n\t} // End method: static get constants\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget accordion_elements() {\r\n\t\t// Get accordion elements and convert the result into an array.\r\n\t\treturn Array.from(document.querySelectorAll(this.options.selectors.accordion));\r\n\t} // End method: get accordion_elements\r\n\r\n\t/**\r\n\t * Adds an instance to a class.\r\n\t * @returns {number} instance_id - The id of the instance (zero indexed).\r\n\t */\r\n\r\n\tstatic addInstance(holder, count_property, list_property, instance) {\r\n\t\t// Generate the instance id from the instance count.\r\n\t\tconst instance_id = holder[count_property];\r\n\t\t// Increment the instance count.\r\n\t\tholder[count_property]++;\r\n\t\t// Add the instance to the instances list.\r\n\t\tholder[list_property][instance_id] = instance;\r\n\t\t// Return the instance id.\r\n\t\treturn instance_id;\r\n\r\n\t} // End method: static addInstance\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\taddAceAccordion() {\r\n\r\n\t\t//\r\n\t\tif (typeof this.constructor.ace_accordion_count !== 'number') {\r\n\t\t\t//\r\n\t\t\tthis.constructor.ace_accordion_count = 0;\r\n\t\t}\r\n\r\n\t\t//\r\n\t\tif (typeof this.constructor.ace_accordions !== 'object') {\r\n\t\t\t//\r\n\t\t\tthis.constructor.ace_accordions = {};\r\n\t\t}\r\n\r\n\t\t// Call the static function to add the instance.\r\n\t\treturn this.constructor.addInstance(this.constructor, 'ace_accordion_count', 'ace_accordions', this);\r\n\r\n\t} // End method: addAceAccordion\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\taddAccordion(accordion_element) {\r\n\r\n\t\t// If the callback option value is a function.\r\n\t\tif (typeof this.options.callbacks.accordion.initialize.before === 'function') {\r\n\t\t\t// Call the callback function, passing null as this and the accordion element as an argument.\r\n\t\t\tthis.options.callbacks.accordion.initialize.before.call(null, accordion_element);\r\n\t\t}\r\n\r\n\t\t// Get the next instance id.\r\n\t\t// The current instance count equals the next instance id because the id is zero indexed.\r\n\t\tconst accordion_id = this.accordion_count;\r\n\r\n\t\t// Create a new accordion.\r\n\t\tconst accordion = new Accordion(this, accordion_id, accordion_element);\r\n\r\n\t\t//\r\n\t\tif (accordion) {\r\n\t\t\t// Call the static function to add the instance.\r\n\t\t\tthis.constructor.addInstance(this, 'accordion_count', 'accordions', accordion);\r\n\t\t}\r\n\r\n\t\t// If the callback option value is a function.\r\n\t\tif (typeof this.options.callbacks.accordion.initialize.after === 'function') {\r\n\t\t\t// Call the callback function, passing the accordion object as this and the accordion element as an argument.\r\n\t\t\tthis.options.callbacks.accordion.initialize.after.call(accordion, accordion_element);\r\n\t\t}\r\n\r\n\t} // End method: addAccordion\r\n\r\n\t/**\r\n\t * AceAccordion class constructor.\r\n\t * @param {object} options_user - A set of override options supplied by the user.\r\n\t * @returns {object} this - The reference to this instance.\r\n\t */\r\n\r\n\tconstructor(options_user) {\r\n\r\n\t\t// For now, assume passed parameter is a correctly formed options object.\r\n\t\t// TO-DO: implement schema checking script.\r\n\r\n\t\t// Merge default options and user options into new object using the imported extend function.\r\n\t\tthis.options = extend([{}, this.constructor.options_default, options_user], true);\r\n\t\t// Add this instance to the static class object and set the instance id on this instance.\r\n\t\tthis.id = this.addAceAccordion();\r\n\t\t// Create a selector for the unique local instance id.\r\n\t\tthis.selector = '[' + this.constructor.constants.id_attribute + '=\"' + this.id + '\"]';\r\n\r\n\t\t//\r\n\t\tthis.accordion_count = 0;\r\n\t\t//\r\n\t\tthis.accordions = {};\r\n\r\n\t\t// If there at least one element matching the accordion selector.\r\n\t\tif (this.accordion_elements.length > 0) {\r\n\t\t\t// For each matching accordion element.\r\n\t\t\tfor (let accordion_element = 0; accordion_element < this.accordion_elements.length; accordion_element++) {\r\n\t\t\t\t// Initialize an accordion.\r\n\t\t\t\tthis.addAccordion(this.accordion_elements[accordion_element]);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// If there are no elements matching the accordion selector.\r\n\t\telse {\r\n\t\t\t// Send a warning to the console.\r\n\t\t\tconsole.warn(this.constructor.name + \": No accordions found using selector: '\" + this.options.selectors.accordion + \"'\");\r\n\t\t}\r\n\r\n\t\t// If debug is true.\r\n\t\tif (this.options.debug) {\r\n\t\t\t// Log the class.\r\n\t\t\tconsole.log('AceAccordion Debug: AceAccordion Class:');\r\n\t\t\tconsole.dir(this.constructor);\r\n\t\t}\r\n\r\n\t\t// Return this instance.\r\n\t\treturn this;\r\n\r\n\t} // End method: constructor\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tdestroy() {\r\n\t\t//\r\n\t} // End method: destroy\r\n\r\n}; // End class: AceAccordion\r\n\r\n// If script is being required as a node module.\r\nif (typeof module !== 'undefined' && module.exports) {\r\n\t// Export the AceAccordion class.\r\n\tmodule.exports = AceAccordion;\r\n}\r\n\n\n//# sourceURL=webpack://AceAccordion/./src/js/ace-accordion.js?");

/***/ }),

/***/ "./src/js/content.js":
/*!***************************!*\
  !*** ./src/js/content.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Defines a Content.\r\n */\r\n\r\nconst Content = class {\r\n\r\n\t/**\r\n\t * Defines constant class variables.\r\n\t */\r\n\r\n\tstatic get constants() {\r\n\t\treturn {\r\n\t\t\tace_attribute: 'data-ace-content',\r\n\t\t\tace_attribute_inner: 'data-ace-content-inner'\r\n\t\t};\r\n\t} // End method: static get constants\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget options() {\r\n\t\t// Return options from the wrapper AceAccordion object.\r\n\t\treturn this.wrapper_item.wrapper_accordion.wrapper_ace_accordion.options;\r\n\t} // End method: get options\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tgenerateId() {\r\n\t\t// Generate a unique id based off wrapper instance ids.\r\n\t\treturn 'accordion-content-' + this.wrapper_item.wrapper_accordion.wrapper_ace_accordion.id + '-' + this.wrapper_item.wrapper_accordion.id + '-' + this.wrapper_item.id;\r\n\t} // End method: generateId\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\thasHeightTransition(computed_styles) {\r\n\t\t// If a computed style object was not passed.\r\n\t\tif (!computed_styles) {\r\n\t\t\t// Get the computed styles of the item element.\r\n\t\t\tcomputed_styles = window.getComputedStyle(this.element);\r\n\t\t}\r\n\t\t// Split the transition property value into an array of values.\r\n\t\tconst transition_property_array = computed_styles.transitionProperty.split(', ');\r\n\t\t// If height is a transition property.\r\n\t\tif (transition_property_array.indexOf('height') >= 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t// If height is not a transition property.\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t} // End method: hasHeightTransition\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tgetComputedHeight(computed_styles) {\r\n\t\t// If a computed style object was not passed.\r\n\t\tif (!computed_styles) {\r\n\t\t\t// Get the computed styles of the item element.\r\n\t\t\tcomputed_styles = window.getComputedStyle(this.element);\r\n\t\t}\r\n\t\t// Get the height and remove 'px' from the end.\r\n\t\tconst height = computed_styles.height.slice(0, -2);\r\n\t\t// Return the unitless pixel value.\r\n\t\treturn height;\r\n\t} // End method: get height\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tconstructor(item, content_element, content_inner_element) {\r\n\r\n\t\t// Set references to the wrapper instances.\r\n\t\tthis.wrapper_item = item;\r\n\r\n\t\t// Add the content element reference.\r\n\t\tthis.element = content_element;\r\n\t\t// Set the ace attribute on the element.\r\n\t\tthis.element.setAttribute(this.constructor.constants.ace_attribute, '');\r\n\t\t// Add the this instance object reference to the element.\r\n\t\tthis.element.ace_object = this;\r\n\r\n\t\t// Add the content inner element reference.\r\n\t\tthis.inner_element = content_inner_element;\r\n\t\t// Set the ace attribute on the element.\r\n\t\tthis.inner_element.setAttribute(this.constructor.constants.ace_attribute_inner, '');\r\n\r\n\t\t// Set the initial_id property.\r\n\t\tthis.initial_id = this.element.id;\r\n\t\t// If the element has an id.\r\n\t\tif (this.initial_id !== '') {\r\n\t\t\t// Assume the initial id is unique.\r\n\t\t}\r\n\t\t// If the element does not have an id.\r\n\t\telse {\r\n\t\t\t// Generate and set a unique id.\r\n\t\t\tthis.element.id = this.generateId();\r\n\t\t}\r\n\r\n\t\t// Set the aria expanded value to false.\r\n\t\tlet aria_hidden_value = true;\r\n\t\t// If the wrapper item is opened.\r\n\t\tif (this.wrapper_item.state === 'opened') {\r\n\t\t\t// Set the aria expanded value equal to true.\r\n\t\t\taria_hidden_value = false;\r\n\t\t}\r\n\t\t// Set the heading aria-expanded attribute.\r\n\t\tthis.element.setAttribute('aria-hidden', aria_hidden_value);\r\n\r\n\t\t// Return this instance.\r\n\t\treturn this;\r\n\r\n\t} // End method: constructor\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tdestroy() {\r\n\r\n\t\t// Remove the reference to this object from the element.\r\n\t\tthis.element.ace_object = undefined;\r\n\r\n\t\t// If the element id matches the initial id.\r\n\t\tif (this.element.id === this.initial_id) {\r\n\t\t\t// Leave as is.\r\n\t\t}\r\n\t\t// If the element id does not match the initial id.\r\n\t\telse {\r\n\t\t\t// Reset the id attribute.\r\n\t\t\tthis.element.setAttribute('id', this.initial_id);\r\n\t\t}\r\n\r\n\t\t// Remove the aria-hidden attribute. \r\n\t\tthis.element.removeAttribute('aria-hidden');\r\n\r\n\t\t// Remove the reference to this object from the parent.\r\n\t\tthis.wrapper_item.content = undefined;\r\n\r\n\t} // End method: destroy\r\n\r\n}; // End class: Content\r\n\r\n// Export the Content class.\r\nmodule.exports = Content;\n\n//# sourceURL=webpack://AceAccordion/./src/js/content.js?");

/***/ }),

/***/ "./src/js/heading.js":
/*!***************************!*\
  !*** ./src/js/heading.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Defines a Heading.\r\n */\r\n\r\nconst Heading = class {\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget options() {\r\n\t\t// Return options from the wrapper AceAccordion object.\r\n\t\treturn this.wrapper_item.wrapper_accordion.wrapper_ace_accordion.options;\r\n\t} // End method: get options\r\n\r\n\t/**\r\n\t * Defines constant class variables.\r\n\t */\r\n\r\n\tstatic get constants() {\r\n\t\treturn {\r\n\t\t\tace_attribute: 'data-ace-heading'\r\n\t\t};\r\n\t} // End method: static get constants\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tdetermineTriggerElement(selector) {\r\n\t\t// If the selector is a string.\r\n\t\tif (typeof selector === 'string') {\r\n\t\t\t// Get trigger element using the selector.\r\n\t\t\tconst custom_trigger_element = this.element.querySelector(selector);\r\n\t\t\t// If the selector matches an element within the heading.\r\n\t\t\tif (custom_trigger_element) {\r\n\t\t\t\t// Return the element.\r\n\t\t\t\treturn custom_trigger_element;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// If the selector is not valid or has no matching element.\r\n\t\t// Return the heading element.\r\n\t\treturn this.element;\r\n\t} // End method: determineTriggerElement\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\thandleClick(event) {\r\n\t\t// Trigger the toggle method on the wrapper item.\r\n\t\tthis.ace_object.wrapper_item.toggle('click', false);\r\n\t} // End method: handleClick\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\thandleKeyDown(event) {\r\n\t\t// Get the accordion parent item.\r\n\t\tconst this_ace_object = event.target.ace_object;\r\n\t\tswitch(event.keyCode) {\r\n\t\t\t// If key code is up arrow.\r\n\t\t\tcase 38:\r\n\t\t\t\tthis_ace_object.wrapper_item.focusTrigger('previous');\r\n\t\t\t\tbreak;\r\n\t\t\t// If key code is down arrow.\r\n\t\t\tcase 40:\r\n\t\t\t\tthis_ace_object.wrapper_item.focusTrigger('next');\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t} // End method: handleKeyDown\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tconstructor(item, heading_element) {\r\n\r\n\t\t// Set references to the wrapper instances.\r\n\t\tthis.wrapper_item = item;\r\n\r\n\t\t// Add the heading element reference.\r\n\t\tthis.element = heading_element;\r\n\r\n\t\t// Set the trigger element.\r\n\t\tthis.trigger_element = this.determineTriggerElement(this.options.heading_trigger_selector);\r\n\r\n\t\t// Add the this instance object reference to the element.\r\n\t\tthis.element.ace_object = this;\r\n\t\t// Add the this instance object reference to the trigger element.\r\n\t\tthis.trigger_element.ace_object = this;\r\n\r\n\t\t// Set the ace attribute on the element.\r\n\t\tthis.element.setAttribute(this.constructor.constants.ace_attribute, '');\r\n\r\n\t\t// Set the heading aria-controls attribute to the item content id.\r\n\t\tthis.trigger_element.setAttribute('aria-controls', this.wrapper_item.content.element.id);\r\n\t\t// Set the aria expanded value to false.\r\n\t\tlet aria_expanded_value = false;\r\n\t\t// If the wrapper item is opened.\r\n\t\tif (this.wrapper_item.state === 'opened') {\r\n\t\t\t// Set the aria expanded value equal to true.\r\n\t\t\taria_expanded_value = true;\r\n\t\t}\r\n\t\t// Set the heading aria-expanded attribute.\r\n\t\tthis.trigger_element.setAttribute('aria-expanded', aria_expanded_value);\r\n\r\n\t\t//\r\n\t\tthis.trigger_element.addEventListener('click', this.handleClick);\r\n\t\t//\r\n\t\tthis.trigger_element.addEventListener('keydown', this.handleKeyDown);\r\n\r\n\t\t// Return this instance.\r\n\t\treturn this;\r\n\r\n\t} // End method: constructor\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tdestroy() {\r\n\t\t\r\n\t\t// Remove the reference to this object from the element.\r\n\t\tthis.element.ace_object = undefined;\r\n\t\t// Remove the reference to this object from the trigger element.\r\n\t\tthis.trigger_element.ace_object = undefined;\r\n\r\n\t\t// Remove the aria-controls attribute. \r\n\t\tthis.trigger_element.removeAttribute('aria-controls');\r\n\t\t// Remove the aria-expanded attribute. \r\n\t\tthis.trigger_element.removeAttribute('aria-expanded');\r\n\r\n\t\t// Remove the click event listener.\r\n\t\tthis.trigger_element.removeEventListener('click', this.handleClick);\r\n\t\t// Remove the key down event listener.\r\n\t\tthis.trigger_element.removeEventListener('keydown', this.handleKeyDown);\r\n\r\n\t\t// Remove the reference to this object from the parent.\r\n\t\tthis.wrapper_item.heading = undefined;\r\n\r\n\t} // End method: destroy\r\n\r\n}; // End class: Heading\r\n\r\n// Export the Heading class.\r\nmodule.exports = Heading;\n\n//# sourceURL=webpack://AceAccordion/./src/js/heading.js?");

/***/ }),

/***/ "./src/js/item.js":
/*!************************!*\
  !*** ./src/js/item.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Require Heading class.\r\nconst Heading = __webpack_require__(/*! ./heading.js */ \"./src/js/heading.js\");\r\n// Require Content class.\r\nconst Content = __webpack_require__(/*! ./content.js */ \"./src/js/content.js\");\r\n\r\n\r\n/**\r\n * Defines an Item.\r\n */\r\n\r\nconst Item = class {\r\n\r\n\t/**\r\n\t * Defines constant class variables.\r\n\t */\r\n\r\n\tstatic get constants() {\r\n\t\tconst id_attribute = 'data-ace-item-id';\r\n\t\tconst global_selector = '[' + id_attribute + ']';\r\n\t\treturn {\r\n\t\t\tglobal_selector: global_selector,\r\n\t\t\tid_attribute: id_attribute,\r\n\t\t\tcontroller_attrubute: 'data-ace-item-controller',\r\n\t\t\tstate_attrubute: 'data-ace-item-state',\r\n\t\t};\r\n\t} // End method: static get constants\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget options() {\r\n\t\t// Return options from the wrapper AceAccordion object.\r\n\t\treturn this.wrapper_accordion.wrapper_ace_accordion.options;\r\n\t} // End method: get options\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget index() {\r\n\t\t// Get the items elements from the wrapper accordion.\r\n\t\tconst items = this.wrapper_accordion.item_elements;\r\n\t\t// Return the index of this item in the list of items.\r\n\t\treturn items.indexOf(this.element);\r\n\t} // End method: get index\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget state() {\r\n\t\t// Returns null if attribute is not set.\r\n\t\treturn this.element.getAttribute(this.constructor.constants.state_attrubute);\r\n\t} // End method: get state\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget controller() {\r\n\t\t// Returns null if attribute is not set.\r\n\t\treturn this.element.getAttribute(this.constructor.constants.controller_attrubute);\r\n\t} // End method: get controller\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget immediateChildAccordions() {\r\n\t\t//\r\n\t\tconst immediate_child_accordions = [];\r\n\t\t//\r\n\t\tconst global_accordion_selector = this.wrapper_accordion.constructor.constants.global_selector;\r\n\t\t//\r\n\t\tconst global_item_selector = this.constructor.constants.global_selector;\r\n\t\t// Get all nested accordions.\r\n\t\tconst nested_accordions = this.element.querySelectorAll(global_accordion_selector);\r\n\t\t//\r\n\t\tlet loop_accordion;\r\n\t\t// For each nested accordion.\r\n\t\tfor (let accordion = 0; accordion < nested_accordions.length; accordion++) {\r\n\t\t\t//\r\n\t\t\tloop_accordion = nested_accordions[accordion];\r\n\t\t\t//\r\n\t\t\tlet loop_accordion_parent_item = loop_accordion.parentNode.closest(global_item_selector);\r\n\t\t\t//\r\n\t\t\tif (loop_accordion_parent_item === this.element) {\r\n\t\t\t\t//\r\n\t\t\t\timmediate_child_accordions.push(loop_accordion.ace_object);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//\r\n\t\treturn immediate_child_accordions;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget previousItem() {\r\n\t\t//\r\n\t\tconst previous_item = this.wrapper_accordion.item_elements[this.index - 1];\r\n\t\t//\r\n\t\tif (previous_item) {\r\n\t\t\t//\r\n\t\t\treturn previous_item;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t//\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tget nextItem() {\r\n\t\t//\r\n\t\tconst next_item = this.wrapper_accordion.item_elements[this.index + 1];\r\n\t\t//\r\n\t\tif (next_item) {\r\n\t\t\t//\r\n\t\t\treturn next_item;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t//\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tset state(state) {\r\n\t\t// Set the item state attribute equal to the passed state.\r\n\t\tthis.element.setAttribute(this.constructor.constants.state_attrubute, state);\r\n\t\t// Return the state value.\r\n\t\treturn state;\r\n\t} // End method: set state\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tset controller(controller) {\r\n\t\t// Set the item controller attribute equal to the passed controller.\r\n\t\tthis.element.setAttribute(this.constructor.constants.controller_attrubute, controller);\r\n\t\t// Return the controller value.\r\n\t\treturn controller;\r\n\t} // End method: set controller\r\n\r\n\t/**\r\n\t * Check if this item matches the criteria.\r\n\t */\r\n\r\n\tmatches(criteria) {\r\n\r\n\t\t// If the criteria is a node list.\r\n\t\tif (criteria instanceof NodeList) {\r\n\t\t\t// Convert the criteria into an array.\r\n\t\t\tcriteria = Array.from(criteria);\r\n\t\t}\r\n\r\n\t\t// If the criteria is an array.\r\n\t\tif (Array.isArray(criteria)) {\r\n\t\t\t// For each value in the criteria array.\r\n\t\t\tfor (let value = 0; value < criteria.length; value++) {\r\n\t\t\t\t// If the recursive call matches the criteria to the item.\r\n\t\t\t\tif (this.matches(criteria[value])) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If the criteria is a number (index).\r\n\t\telse if (typeof criteria === 'number') {\r\n\t\t\t// If the criteria is an integer.\r\n\t\t\tif (Number.isInteger(criteria)) {\r\n\t\t\t\t// If the criteria is greater than or equal to zero.\r\n\t\t\t\tif (criteria >= 0) {\r\n\t\t\t\t\t// If the item matches the criteria index.\r\n\t\t\t\t\tif (this.index === criteria) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If the criteria is a string (selector).\r\n\t\telse if (typeof criteria === 'string') {\r\n\t\t\t// If the item matches the criteria selector.\r\n\t\t\tif (this.element.matches(criteria)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If the criteria is an element.\r\n\t\telse if (criteria instanceof Element) {\r\n\t\t\t// If the item matches the criteria element.\r\n\t\t\tif (this.element === criteria) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If the item does not match the criteria.\r\n\t\treturn false;\r\n\r\n\t} // End method: matches\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\topen(controller = '', immediate = false) {\r\n\r\n\t\t// If the item is not already opened or in the process of opening.\r\n\t\tif (this.state !== 'opened' && this.state !== 'opening') {\r\n\r\n\t\t\t// Set the controller used to open the item.\r\n\t\t\tthis.controller = controller;\r\n\r\n\t\t\t// If the multiple_open_items option is set to false.\r\n\t\t\tif (this.options.multiple_open_items === false) {\r\n\t\t\t\t// Get all items in this accordion.\r\n\t\t\t\tlet items = this.wrapper_accordion.items;\r\n\t\t\t\t// For each item.\r\n\t\t\t\tfor (let item = 0; item < items.length; item++) {\r\n\t\t\t\t\t// If this element is not equal to the current loop item element.\r\n\t\t\t\t\tif (this.element !== items[item].element) {\r\n\t\t\t\t\t\t// Close the loop item.\r\n\t\t\t\t\t\titems[item].close('', false);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} // End: options.multiple_open_items\r\n\r\n\t\t\t// Update the aria-expanded property on the heading trigger element.\r\n\t\t\tthis.heading.trigger_element.setAttribute('aria-expanded', 'true');\r\n\t\t\t// Update the aria-hidden attribute on the content element.\r\n\t\t\tthis.content.element.setAttribute('aria-hidden', 'false');\r\n\r\n\t\t\t// If height is a transition property on the content element and the immediate flag is not true.\r\n\t\t\tif (this.content.hasHeightTransition() && !immediate) {\r\n\t\t\t\t// Get the current content height.\r\n\t\t\t\tconst content_height_start = this.content.getComputedHeight();\r\n\t\t\t\t// Set the content to its starting height.\r\n\t\t\t\tthis.content.element.style.height = content_height_start + 'px';\r\n\t\t\t\t// Update the item state.\r\n\t\t\t\tthis.state = 'opening';\r\n\t\t\t\t// Get the height of the inner content.\r\n\t\t\t\tconst content_inner_height = this.content.inner_element.offsetHeight;\r\n\t\t\t\t// Set the content height to match the content inner height.\r\n\t\t\t\tthis.content.element.style.height = content_inner_height + 'px';\r\n\t\t\t}\r\n\t\t\t// If height is not a transition property or the immediate flag is true.\r\n\t\t\telse {\r\n\t\t\t\t// Open immediately.\r\n\t\t\t\tthis.open_finish();\r\n\t\t\t}\r\n\r\n\t\t} // End: state check\r\n\r\n\t} // End method: open\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\topen_finish() {\r\n\t\t// Update the item state.\r\n\t\tthis.state = 'opened';\r\n\t\t// Remove the inline height style, if there is one.\r\n\t\tthis.content.element.style.height = '';\r\n\t} // End method: open_finish\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tclose(controller = '', immediate = false) {\r\n\t\t// If the item is not already closed or in the process of closing.\r\n\t\tif (this.state !== 'closed' && this.state !== 'closing') {\r\n\t\t\t// If the passed controller equals the controller set on the item, or no controller was passed.\r\n\t\t\tif (controller === this.controller || controller === '') {\r\n\t\t\t\t// If height is a transition property on the content element and the immediate flag is not true.\r\n\t\t\t\tif (this.content.hasHeightTransition() && !immediate) {\r\n\t\t\t\t\t// Get the current content height.\r\n\t\t\t\t\tconst content_height_start = this.content.getComputedHeight();\r\n\t\t\t\t\t// Set the content to its starting height.\r\n\t\t\t\t\tthis.content.element.style.height = content_height_start + 'px';\r\n\t\t\t\t\t// Update the item state.\r\n\t\t\t\t\tthis.state = 'closing';\r\n\t\t\t\t\t// This line does nothing but force repaint of the content element for the transition to work properly.\r\n\t\t\t\t\tthis.content.element.offsetHeight;\r\n\t\t\t\t\t// Set the content height to zero.\r\n\t\t\t\t\tthis.content.element.style.height = '0px';\r\n\t\t\t\t}\r\n\t\t\t\t// If height is not a transition property or the immediate flag is true.\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Close immediately.\r\n\t\t\t\t\tthis.close_finish();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Do nothing. Do not have proper controller access.\r\n\t\t\t}\r\n\t\t} // End: state check\r\n\t} // End method: close\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tclose_finish() {\r\n\r\n\t\t// Update the aria-expanded property on the heading trigger element.\r\n\t\tthis.heading.trigger_element.setAttribute('aria-expanded', 'true');\r\n\t\t// Update the aria-hidden attribute on the content element.\r\n\t\tthis.content.element.setAttribute('aria-hidden', 'false');\r\n\r\n\t\t// Update the item state.\r\n\t\tthis.state = 'closed';\r\n\r\n\t\t// Remove the inline height style, if there is one.\r\n\t\tthis.content.element.style.height = '';\r\n\r\n\t\t// Clear the controller value.\r\n\t\tthis.controller = '';\r\n\r\n\t\t// If the close_nested_items option is set to true.\r\n\t\tif (this.options.close_nested_items === true) {\r\n\t\t\t//\r\n\t\t\tconst immediateChildAccordions = this.immediateChildAccordions;\r\n\t\t\t//\r\n\t\t\tlet loop_accordion;\r\n\t\t\t//\r\n\t\t\tfor (let accordion = 0; accordion < immediateChildAccordions.length; accordion++) {\r\n\t\t\t\t//\r\n\t\t\t\tloop_accordion = immediateChildAccordions[accordion];\r\n\t\t\t\t//\r\n\t\t\t\tlet loop_item;\r\n\t\t\t\t//\r\n\t\t\t\tfor (let item in loop_accordion.items) {\r\n\t\t\t\t\t//\r\n\t\t\t\t\tloop_item = loop_accordion.items[item];\r\n\t\t\t\t\t//\r\n\t\t\t\t\tloop_item.close('', true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} // End: options.close_nested_items\r\n\r\n\t} // End method: close_finish\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\ttoggle(controller, immediate = false) {\r\n\t\t// If this item is opening, or opened.\r\n\t\tif (this.state === 'opening' || this.state === 'opened') {\r\n\t\t\tthis.close(controller, immediate);\r\n\t\t}\r\n\t\t// If this item is closing, or closed.\r\n\t\telse if (this.state === 'closing' || this.state === 'closed') {\r\n\t\t\t// Open the item.\r\n\t\t\tthis.open(controller, immediate);\r\n\t\t}\r\n\t} // End method: toggle\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\thandleTransitionEnd(event) {\r\n\t\t// If the transitionend event was on the height property.\r\n\t\tif (event.propertyName === 'height') {\r\n\t\t\t// Get the item object.\r\n\t\t\tconst item = this.ace_object.wrapper_item;\r\n\t\t\t// If this item is opening.\r\n\t\t\tif (item.state === 'opening') {\r\n\t\t\t\t// Finish opening the item.\r\n\t\t\t\titem.open_finish();\r\n\t\t\t}\r\n\t\t\t// If this item is closing.\r\n\t\t\telse if (item.state === 'closing') {\r\n\t\t\t\t// Finish closing the item.\r\n\t\t\t\titem.close_finish();\r\n\t\t\t}\r\n\t\t}\r\n\t} // End method: handleTransitionEnd\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\thandleMouseEnter(event) {\r\n\t\t//\r\n\t\tconst this_item = this.ace_object;\r\n\t\t//\r\n\t\tif (this_item.options.trigger_on_hover) {\r\n\t\t\t//\r\n\t\t\tthis_item.open('hover');\r\n\t\t}\r\n\t} // End method: handleMouseEnter\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\thandleMouseLeave(event) {\r\n\t\t//\r\n\t\tconst this_item = this.ace_object;\r\n\t\t//\r\n\t\tif (this_item.options.trigger_on_hover) {\r\n\t\t\t//\r\n\t\t\tthis_item.close('hover');\r\n\t\t}\r\n\t} // End method: handleMouseEnter\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tfocusTrigger(option) {\r\n\t\t// If a previous option is passed.\r\n\t\tif (option === 'previous' && this.previousItem) {\r\n\t\t\t//\r\n\t\t\tthis.previousItem.ace_object.focusTrigger();\r\n\t\t}\r\n\t\t// If a next option is passed.\r\n\t\telse if (option === 'next' && this.nextItem) {\r\n\t\t\t//\r\n\t\t\tthis.nextItem.ace_object.focusTrigger();\r\n\t\t}\r\n\t\t// If no valid option passed.\r\n\t\telse {\r\n\t\t\tthis.heading.trigger_element.focus();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tconstructor(accordion, item_id, item_element) {\r\n\r\n\t\t// Set a reference to the wrapper instance.\r\n\t\tthis.wrapper_accordion = accordion;\r\n\r\n\t\t// Add the item element reference.\r\n\t\tthis.element = item_element;\r\n\r\n\t\t// Add the this instance object reference to the element.\r\n\t\tthis.element.ace_object = this;\r\n\r\n\t\t// Add this instance to the wrapper instance and set the instance id.\r\n\t\tthis.id = item_id;\r\n\r\n\t\t// Set the Accordion class instance id data attribute.\r\n\t\tthis.element.setAttribute(this.constructor.constants.id_attribute, this.id);\r\n\r\n\t\t// Create a unique selector for this item.\r\n\t\tthis.selector = this.wrapper_accordion.selector + ' > [' + this.constructor.constants.id_attribute + '=\"' + this.id + '\"]';\r\n\r\n\t\t// Initialize the item state.\r\n\t\tlet initial_state = 'closed';\r\n\t\t// If the default_open_items option value is not false, null, or undefined.\r\n\t\tif (this.options.default_open_items !== false || this.options.default_open_items !== null || typeof this.options.default_open_items !== 'undefined') {\r\n\t\t\t// If the element matches the default_open_items value.\r\n\t\t\tif (this.matches(this.options.default_open_items)) {\r\n\t\t\t\t// Set the item state value to opened.\r\n\t\t\t\tinitial_state = 'opened';\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Set the item state.\r\n\t\tthis.state = initial_state;\r\n\r\n\t\t// Get the content element.\r\n\t\tconst content_element = this.element.querySelector(this.selector + ' > ' + this.options.selectors.content);\r\n\t\t// Get the content inner element.\r\n\t\tconst content_inner_element = this.element.querySelector(this.selector + ' > ' + this.options.selectors.content + ' > ' + this.options.selectors.content_inner);\r\n\t\t//\r\n\t\tif (content_element && content_inner_element) {\r\n\t\t\t//\r\n\t\t\tthis.content = new Content(this, content_element, content_inner_element);\r\n\t\t}\r\n\r\n\t\t// Get the heading element.\r\n\t\tconst heading_element = this.element.querySelector(this.selector + ' > ' + this.options.selectors.heading);\r\n\t\t//\r\n\t\tif (heading_element) {\r\n\t\t\t//\r\n\t\t\tthis.heading = new Heading(this, heading_element);\r\n\t\t}\r\n\r\n\t\t//\r\n\t\tthis.transitionendListener = this.content.element.addEventListener('transitionend', this.handleTransitionEnd);\r\n\t\t//\r\n\t\tthis.transitionendListener = this.element.addEventListener('mouseenter', this.handleMouseEnter);\r\n\t\t//\r\n\t\tthis.transitionendListener = this.element.addEventListener('mouseleave', this.handleMouseLeave);\r\n\r\n\t\t// Return this instance.\r\n\t\treturn this;\r\n\r\n\t} // End method: constructor\r\n\r\n\t/**\r\n\t *\r\n\t */\r\n\r\n\tdestroy() {\r\n\t\t//\r\n\t} // End method: destroy\r\n\r\n}; // End class: Item\r\n\r\n// Export the Item class.\r\nmodule.exports = Item;\n\n//# sourceURL=webpack://AceAccordion/./src/js/item.js?");

/***/ })

/******/ });