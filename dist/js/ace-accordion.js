var AceAccordion =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/ace-accordion.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@alexspirgel/extend/extend.js":
/*!****************************************************!*\
  !*** ./node_modules/@alexspirgel/extend/extend.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * extend v2.0.3\r\n * https://github.com/alexspirgel/extend\r\n */\r\n\r\n/**\r\n * Extends an object with another object(s).\r\n *\r\n * @param {array} objects - Array of objects containing the resulting object and the objects to merge into it.\r\n * @param {boolean} [deep] - Optional flag to enable or disable recursive merge.\r\n *\r\n * @returns {object} The object that has been extended.\r\n */\r\n\r\nconst extend = (objects, deep) => {\r\n\r\n\t/**\r\n\t * Extends an object with another object.\r\n\t *\r\n\t * @param {object} target_object - The target object to be merged into.\r\n\t * @param {object} merge_object - The object to merge into the target object.\r\n\t * @param {boolean} [deep] - Optional flag to enable or disable recursive merge.\r\n\t *\r\n\t * @returns {object} The object that has been extended.\r\n\t */\r\n\r\n\tconst extendObject = (target_object, merge_object, deep) => {\r\n\t\t// For each property in the merge_object.\r\n\t\tfor (let property in merge_object) {\r\n\t\t\t// If the merge_object value is an object, is not null, and the deep flag is true.\r\n\t\t\tif (typeof merge_object[property] === 'object' && merge_object[property] !== null && deep) {\r\n\t\t\t\t// If the merge_object value is a special case.\r\n\t\t\t\tif (merge_object[property] instanceof Window || merge_object[property] instanceof HTMLDocument || merge_object[property] instanceof Element) {\r\n\t\t\t\t\t// Set the target_object property value equal to the merge_object property value.\r\n\t\t\t\t\ttarget_object[property] = merge_object[property];\r\n\t\t\t\t\t// Continue past the normal deep object handling.\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t// If the merge_object value is an array.\r\n\t\t\t\tif (Array.isArray(merge_object[property]) || merge_object[property] instanceof NodeList) {\r\n\t\t\t\t\tif (merge_object[property] instanceof NodeList) {\r\n\t\t\t\t\t\tmerge_object[property] = Array.from(merge_object[property]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Set the target_object value equal to an empty array (arrays are replaced, not merged).\r\n\t\t\t\t\ttarget_object[property] = [];\r\n\t\t\t\t}\r\n\t\t\t\t// If the target_object value is not an object or if it is null.\r\n\t\t\t\telse if (typeof target_object[property] !== 'object' || target_object[property] === null) {\r\n\t\t\t\t\t// Set the target_object value equal to an empty object.\r\n\t\t\t\t\ttarget_object[property] = {};\r\n\t\t\t\t}\r\n\t\t\t\t// Call the extendObject function recursively.\r\n\t\t\t\textendObject(target_object[property], merge_object[property], deep);\r\n\t\t\t\t// Continue to the next property, skipping the normal value assignment.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// Set the target_object property value equal to the merge_object property value (primitive values or shallow calls).\r\n\t\t\ttarget_object[property] = merge_object[property];\r\n\t\t}\r\n\t\t// Return the target_object.\r\n\t\treturn target_object;\r\n\t}; // End function extendObject.\r\n\r\n\t// If objects length is greater than 1.\r\n\tif (objects.length > 1) {\r\n\t\t// For each object in objects (skipping the first object).\r\n\t\tfor (let object = 1; object < objects.length; object++) {\r\n\t\t\t// If the current loop item is an object and not null.\r\n\t\t\tif (typeof objects[object] === 'object' && objects[object] !== null) {\r\n\t\t\t\t// Extend the first object with the current loop object.\r\n\t\t\t\textendObject(objects[0], objects[object], deep);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Return the first object in the array.\r\n\treturn objects[0];\r\n\r\n}; // End function extend.\r\n\r\n// If script is being required as a node module.\r\nif (typeof module !== 'undefined' && module.exports) {\r\n\t// Export the extend function.\r\n\tmodule.exports = extend;\r\n}\n\n//# sourceURL=webpack://AceAccordion/./node_modules/@alexspirgel/extend/extend.js?");

/***/ }),

/***/ "./src/js/accordion.js":
/*!*****************************!*\
  !*** ./src/js/accordion.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Require Item class.\nconst Item = __webpack_require__(/*! ./item.js */ \"./src/js/item.js\");\n\n/**\n * Defines an Accordion.\n */\n\nconst Accordion = class {\n\n\t/**\n\t * Defines constant class variables.\n\t */\n\n\tstatic get constants() {\n\t\treturn {\n\t\t\tcount_property: 'accordion_count',\n\t\t\tinstances_property: 'accordions',\n\t\t\tid_attribute: 'data-accordion-id',\n\t\t\titem_instances_property: 'items'\n\t\t};\n\t} // End method: static get constants\n\n\t/**\n\t *\n\t */\n\n\tget options() {\n\t\t// Return options from the wrapper AceAccordion object.\n\t\treturn this.wrapper_ace_accordion.options;\n\t} // End method: get options\n\n\t/**\n\t *\n\t */\n\n\tget parent_accordion() {\n\t\t// Get the parent node.\n\t\t// We do this because Element.closest can match with itself.\n\t\tconst parent_node = this.element.parentNode;\n\t\t// Get the closest parent accordion.\n\t\tlet parent_accordion = parent_node.closest('[' + this.constructor.constants.id_attribute + ']');\n\t\t// If a parent accordion exists.\n\t\tif (parent_accordion) {\n\t\t\t// Set parent_accordion equal to the ace object.\n\t\t\tparent_accordion = parent_accordion.ace_object;\n\t\t}\n\t\t// Return the parent accordion object, or null.\n\t\treturn parent_accordion;\n\t} // End method: get parent_accordion\n\n\t/**\n\t *\n\t */\n\n\tget nested_level() {\n\t\t// Return the private nested level.\n\t\treturn this._nested_level;\n\t} // End method: get nested_level\n\n\t/**\n\t *\n\t */\n\n\tset nested_level(level) {\n\t\t// Set the private nested level value.\n\t\tthis._nested_level = level;\n\t\t// If this accordion has items.\n\t\tif (this.items) {\n\t\t\t// For each item in this accordion.\n\t\t\tfor (let item in this.items) {\n\t\t\t\t// If this item has a heading.\n\t\t\t\tif (this.items[item].heading) {\n\t\t\t\t\t// Set the nested level value on the heading.\n\t\t\t\t\tthis.items[item].heading.element.setAttribute('aria-level', this._nested_level);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} // End method: set nested_level\n\n\t/**\n\t *\n\t */\n\n\tupdateNestedLevel() {\n\t\t// If there is a parent accordion.\n\t\tif (this.parent_accordion) {\n\t\t\t// Get the parent level from calculating the parent nested level.\n\t\t\tconst parent_level = this.parent_accordion.updateNestedLevel();\n\t\t\t// Increment the parent level and set this nested level.\n\t\t\tthis.nested_level = parent_level + 1;\n\t\t}\n\t\t// If this is the top most parent accordion.\n\t\telse {\n\t\t\t// Set this accordion level to one.\n\t\t\tthis.nested_level = 1;\n\t\t}\n\t\t// Return the nested level.\n\t\treturn this.nested_level;\n\t} // End method: updateNestedLevel\n\n\t/**\n\t *\n\t */\n\n\tget item_elements() {\n\t\t// Get item elements and convert the result into an array.\n\t\treturn Array.from(this.element.querySelectorAll(this.selector + ' > ' + this.options.selectors.item));\n\t} // End method: get item_elements\n\n\t/**\n\t *\n\t */\n\n\taddInstance() {\n\t\t// Call the static function to add the instance and return the instance id.\n\t\tconst instance_id = this.wrapper_ace_accordion.constructor.addInstance({\n\t\t\tinstance: this, // The instance to add.\n\t\t\tclass_reference: this.wrapper_ace_accordion, // The class to add the instance to.\n\t\t\tcount_property: this.constructor.constants.count_property, // The count property on the class.\n\t\t\tlist_property: this.constructor.constants.instances_property // The instance list property on the class.\n\t\t});\n\t\t// Return the instance id.\n\t\treturn instance_id;\n\t} // End method: addInstance\n\n\t/**\n\t *\n\t */\n\n\taddItem(item_element) {\n\n\t\t// If the callback option value is a function.\n\t\tif (typeof this.options.callbacks.item.initialize.before === 'function') {\n\t\t\t// Call the callback function, passing null as this and the item element as an argument.\n\t\t\tthis.options.callbacks.item.initialize.before.call(null, item_element);\n\t\t}\n\n\t\t// Create a new item.\n\t\tconst item = new Item(this, item_element);\n\n\t\t// If the callback option value is a function.\n\t\tif (typeof this.options.callbacks.item.initialize.after === 'function') {\n\t\t\t// Call the callback function, passing the item object as this and the item element as an argument.\n\t\t\tthis.options.callbacks.item.initialize.after.call(item, item_element);\n\t\t}\n\n\t} // End: method: addItem\n\n\t/**\n\t *\n\t */\n\n\tconstructor(ace_accordion, accordion_element) {\n\n\t\t// Set a reference to the wrapper instance.\n\t\tthis.wrapper_ace_accordion = ace_accordion;\n\n\t\t// Add the accordion element reference.\n\t\tthis.element = accordion_element;\n\n\t\t// Add the this instance object reference to the element.\n\t\tthis.element.ace_object = this;\n\n\t\t// Add this instance to the wrapper instance and set the instance id.\n\t\tthis.id = this.addInstance();\n\n\t\t// Get this nested level.\n\t\tthis.updateNestedLevel();\n\n\t\t// Set the AceAccordion class instance id data attribute.\n\t\tthis.element.setAttribute(this.wrapper_ace_accordion.constructor.constants.id_attribute, this.wrapper_ace_accordion.id);\n\t\t// Set the Accordion class instance id data attribute.\n\t\tthis.element.setAttribute(this.constructor.constants.id_attribute, this.id);\n\n\t\t// Create a unique selector for this Accordion.\n\t\tthis.selector = this.wrapper_ace_accordion.selector + '[' + this.constructor.constants.id_attribute + '=\"' + this.id + '\"]';\n\n\t\t// If there is at least one item.\n\t\tif (this.item_elements.length > 0) {\n\t\t\t// For each item element.\n\t\t\tfor(let index = 0; index < this.item_elements.length; index++) {\n\t\t\t\t// Initialize an item.\n\t\t\t\tthis.addItem(this.item_elements[index]);\n\t\t\t}\n\t\t}\n\t\t// If there are no items in this accordion.\n\t\telse {\n\t\t\t// If debug is true.\n\t\t\tif (this.options.debug) {\n\t\t\t\t// Send a warning to the console.\n\t\t\t\tconsole.warn(this.constructor.name + \": No items found using selector: '\" + this.options.selectors.item + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t// Return this instance.\n\t\treturn this;\n\n\t} // End method: constructor\n\n}; // End class: Accordion\n\n// Export the Accordion class.\nmodule.exports = Accordion;\n\n//# sourceURL=webpack://AceAccordion/./src/js/accordion.js?");

/***/ }),

/***/ "./src/js/ace-accordion.js":
/*!*********************************!*\
  !*** ./src/js/ace-accordion.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * AceAccordion v1.0.0\n * https://github.com/alexspirgel/accordion\n */\n\n// Require extend function.\nconst extend = __webpack_require__(/*! @alexspirgel/extend */ \"./node_modules/@alexspirgel/extend/extend.js\");\n// Require Accordion class.\nconst Accordion = __webpack_require__(/*! ./accordion.js */ \"./src/js/accordion.js\");\n\n/**\n * Defines an Ace Accordion (a handling wrapper for the Accordion Class).\n */\n\nconst AceAccordion = class {\n\n\t/**\n\t * Defines the default set of options.\n\t */\n\n\tstatic get options_default() {\n\t\treturn {\n\t\t\tselectors: {\n\t\t\t\taccordion: '.accordion', // {string} Custom accordion element selector.\n\t\t\t\titem: '.accordion__item', // {string} Custom item element selector.\n\t\t\t\theading: '.accordion__item__heading', // {string} Custom heading element selector.\n\t\t\t\tcontent: '.accordion__item__content' // {string} Custom content element selector.\n\t\t\t},\n\t\t\t// accessibility_warnings: true, // {boolean} Log detected accessibility issues as warnings.\n\t\t\t// close_nested_items: false, // {boolean} Close immediate nested items. Can chain to close nested items depending on nested options.\n\t\t\tdefault_open_items: null, // {number|string|object|array} Initializes item(s) to default open by default.\n\t\t\t// multiple_open_items: true, // {boolean} Allow multiple items to be open at the same time.\n\t\t\t// open_anchored_items: false, // {boolean} When anchored to an accordion item, open it.\n\t\t\tcallbacks: {\n\t\t\t\taccordion: {\n\t\t\t\t\tinitialize: {\n\t\t\t\t\t\tbefore: null,\n\t\t\t\t\t\tafter: null\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\titem: {\n\t\t\t\t\tinitialize: {\n\t\t\t\t\t\tbefore: null,\n\t\t\t\t\t\tafter: null\n\t\t\t\t\t},\n\t\t\t\t\topen: {\n\t\t\t\t\t\t// before: null,\n\t\t\t\t\t\t// after: null\n\t\t\t\t\t},\n\t\t\t\t\tclose: {\n\t\t\t\t\t\t// before: null,\n\t\t\t\t\t\t// after: null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdebug: false // Log helpful messages to the console for development.\n\t\t};\n\t} // End method: static get options_default\n\n\t/**\n\t * Defines constant class variables.\n\t */\n\n\tstatic get constants() {\n\t\treturn {\n\t\t\tcount_property: 'ace_accordion_count',\n\t\t\tinstances_property: 'ace_accordions',\n\t\t\tid_attribute: 'data-ace-accordion-id'\n\t\t};\n\t} // End method: static get constants\n\n\t/**\n\t *\n\t */\n\n\tget accordion_elements() {\n\t\t// Get accordion elements and convert the result into an array.\n\t\treturn Array.from(document.querySelectorAll(this.options.selectors.accordion));\n\t} // End method: get accordion_elements\n\n\t/**\n\t * Adds an instance to a class.\n\t * @returns {number} instance_id - The id of the instance (zero indexed).\n\t */\n\n\tstatic addInstance(parameters) {\n\n\t\t// If the class instance count has not been initialized.\n\t\tif (typeof parameters.class_reference[parameters.count_property] !== 'number') {\n\t\t\t// Set the class instance count to 0.\n\t\t\tparameters.class_reference[parameters.count_property] = 0;\n\t\t}\n\n\t\t// If the class instance list has not been initialized.\n\t\tif (typeof parameters.class_reference[parameters.list_property] !== 'object') {\n\t\t\t// Initialize the class instances list.\n\t\t\tparameters.class_reference[parameters.list_property] = {};\n\t\t}\n\n\t\t// Increment the class instance count.\n\t\tparameters.class_reference[parameters.count_property]++;\n\t\t// Generate the instance id from the instance count. Subtract one to have the id be zero indexed.\n\t\tconst instance_id = parameters.class_reference[parameters.count_property] - 1;\n\t\t// Add the instance to the class instances object.\n\t\tparameters.class_reference[parameters.list_property][instance_id] = parameters.instance;\n\n\t\t// Return this instance's unique id.\n\t\treturn instance_id;\n\n\t} // End method: static addInstance\n\n\t/**\n\t *\n\t */\n\n\taddInstance() {\n\t\t// Call the static function to add the instance and return the instance id.\n\t\tconst instance_id = this.constructor.addInstance({\n\t\t\tinstance: this, // The instance to add.\n\t\t\tclass_reference: this.constructor, // The class to add the instance to.\n\t\t\tcount_property: this.constructor.constants.count_property, // The count property on the class.\n\t\t\tlist_property: this.constructor.constants.instances_property // The instance list property on the class.\n\t\t});\n\t\t// Return the instance id.\n\t\treturn instance_id;\n\t} // End method: addInstance\n\n\t/**\n\t *\n\t */\n\n\taddAccordion(accordion_element) {\n\n\t\t// If the callback option value is a function.\n\t\tif (typeof this.options.callbacks.accordion.initialize.before === 'function') {\n\t\t\t// Call the callback function, passing null as this and the accordion element as an argument.\n\t\t\tthis.options.callbacks.accordion.initialize.before.call(null, accordion_element);\n\t\t}\n\n\t\t// Create a new accordion.\n\t\tconst accordion = new Accordion(this, accordion_element);\n\n\t\t// If the callback option value is a function.\n\t\tif (typeof this.options.callbacks.accordion.initialize.after === 'function') {\n\t\t\t// Call the callback function, passing the accordion object as this and the accordion element as an argument.\n\t\t\tthis.options.callbacks.accordion.initialize.after.call(accordion, accordion_element);\n\t\t}\n\n\t} // End method: addAccordion\n\n\t/**\n\t * AceAccordion class constructor.\n\t * @param {object} options_user - A set of override options supplied by the user.\n\t * @returns {object} this - The reference to this instance.\n\t */\n\n\tconstructor(options_user) {\n\n\t\t// For now, assume passed parameter is a correctly formed options object.\n\t\t// TO-DO: implement schema checking script.\n\n\t\t// Merge default options and user options into new object using the imported extend function.\n\t\tthis.options = extend([{}, this.constructor.options_default, options_user], true);\n\t\t// Add this instance to the static class object and set the instance id on this instance.\n\t\tthis.id = this.addInstance();\n\t\t// Create a selector for the unique local instance id.\n\t\tthis.selector = '[' + this.constructor.constants.id_attribute + '=\"' + this.id + '\"]';\n\n\t\t// If there at least one element matching the accordion selector.\n\t\tif (this.accordion_elements.length > 0) {\n\t\t\t// For each matching accordion element.\n\t\t\tfor (let accordion_element = 0; accordion_element < this.accordion_elements.length; accordion_element++) {\n\t\t\t\t// Initialize an accordion.\n\t\t\t\tthis.addAccordion(this.accordion_elements[accordion_element]);\n\t\t\t}\n\t\t}\n\t\t// If there are no elements matching the accordion selector.\n\t\telse {\n\t\t\t// Send a warning to the console.\n\t\t\tconsole.warn(this.constructor.name + \": No accordions found using selector: '\" + this.options.selectors.accordion + \"'\");\n\t\t}\n\n\t\t// If debug is true.\n\t\tif (this.options.debug) {\n\t\t\t// Log the class.\n\t\t\tconsole.log('AceAccordion Debug: AceAccordion Class:');\n\t\t\tconsole.dir(this.constructor);\n\t\t}\n\n\t\t// Return this instance.\n\t\treturn this;\n\n\t} // End method: constructor\n\n\t\n\t/******************************************************\n\t* OLD CODE WAITING TO BE REFACTORED BEYOND THIS POINT *\n\t*******************************************************/\n\t\n\n\t/**\n\t * Handles a click event on an accordion item heading.\n\t */\n\n\tstatic headingClickEventHandler(event) {\n\t\t// Get the accordion parent item.\n\t\tconst accordion_item = event.target.accordion_item_parent;\n\t\t// Toggle the accordion item.\n\t\tAccordion.toggleItem(accordion_item);\n\t} // End function: headingClickEventHandler.\n\n\t/**\n\t * Handles a key down event on an accordion item heading.\n\t */\n\n\tstatic headingKeyDownEventHandler(event) {\n\t\t// Get the accordion parent item.\n\t\tconst accordion_item = event.target.accordion_item_parent;\n\t\tswitch(event.keyCode) {\n\t\t\t// If key code is up arrow.\n\t\t\tcase 38:\n\t\t\t\tAccordion.focusItem(accordion_item, 'previous');\n\t\t\t\tbreak;\n\t\t\t// If key code is down arrow.\n\t\t\tcase 40:\n\t\t\t\tAccordion.focusItem(accordion_item, 'next');\n\t\t\t\tbreak;\n\t\t}\n\t} // End function: headingKeyDownEventHandler.\n\n\t/**\n\t * Handles an open transition end event.\n\t */\n\n\tstatic headingOpenTransitionEndEventHandler(event) {\n\t\tconst accordion_parent = event.target.accordion_parent;\n\t\tconst accordion_options = accordion_parent.accordion_options;\n\t\tif(event.target.matches(accordion_options.selectors.item)){\n\t\t\t\tAccordion.finishOpeningItem(event.target);\n\t\t}\n\t} // End function: headingOpenTransitionEndEventHandler.\n\n\t/**\n\t * Handles a close transition end event.\n\t */\n\n\tstatic headingCloseTransitionEndEventHandler(event) {\n\t\tconst accordion_parent = event.target.accordion_parent;\n\t\tconst accordion_options = accordion_parent.accordion_options;\n\t\tif(event.target.matches(accordion_options.selectors.item)){\n\t\t\t\tAccordion.finishClosingItem(event.target);\n\t\t}\n\t} // End function: headingCloseTransitionEndEventHandler.\n\n\tstatic openItem(accordion_item, skip_transition) {\n\n\t\t// Remove the close transitionend event listener.\n\t\taccordion_item.removeEventListener('transitionend', Accordion.headingCloseTransitionEndEventHandler);\n\t\t// Get the accordion element.\n\t\tconst accordion_parent = accordion_item.accordion_parent;\n\t\t// Get the accordion options.\n\t\tconst accordion_options = accordion_parent.accordion_options;\n\n\t\t// If multiple open items are not allowed.\n\t\tif(accordion_options.multiple_open_items === false) {\n\t\t\t// Get all the accordion items within this accordion.\n\t\t\tconst accordion_items = accordion_parent.children;\n\t\t\t// For each accordion item.\n\t\t\tfor(let accordion_item = 0; accordion_item < accordion_items.length; accordion_item++) {\n\t\t\t\t// If the accordion item is open or opening.\n\t\t\t\tif(accordion_items[accordion_item].matches('[' + Accordion.item_state_attrubute + '=\"opening\"], [' + Accordion.item_state_attrubute + '=\"opened\"]')) {\n\t\t\t\t\t// Close the accordion item.\n\t\t\t\t\tAccordion.closeItem(accordion_items[accordion_item]);\n\t\t\t\t}\n\t\t\t}\n\t\t} // End option: multiple_open_items.\n\n\t\t// Get the current item height.\n\t\tconst item_height_start = accordion_item.offsetHeight;\n\t\t// Set the item to its current height, keeping it at that height.\n\t\taccordion_item.style.height = item_height_start + 'px';\n\t\t// Set the accordion item state attribute to show the beginning of the opening process.\n\t\taccordion_item.setAttribute(Accordion.item_state_attrubute, 'opening');\n\t\t// Set the related aria attributes to show the accordion is open.\n\t\taccordion_item.accordion_item_heading.setAttribute('aria-expanded', 'true');\n\t\taccordion_item.accordion_item_content.setAttribute('aria-hidden', 'false');\n\n\t\t// Skip transition is true.\n\t\tif(skip_transition) {\n\t\t\t// Finish opening the item immediately, disregarding transitions.\n\t\t\tAccordion.finishOpeningItem(accordion_item);\n\t\t}\n\t\t// If skip transition is false or not passed, continue with the transition as normal.\n\t\telse {\n\t\t\t// Get the height of the accordion heading.\n\t\t\tconst item_heading_height = accordion_item.accordion_item_heading.offsetHeight;\n\t\t\t// Get the height of the accordion content.\n\t\t\tconst item_content_height = accordion_item.accordion_item_content.offsetHeight;\n\t\t\t// Calculate the end height for the accordion item.\n\t\t\tconst item_height_end = item_heading_height + item_content_height;\n\t\t\t// Add an open transitionend event listener to the accordion item.\n\t\t\taccordion_item.addEventListener('transitionend', Accordion.headingOpenTransitionEndEventHandler);\n\t\t\t// Set the accordion item to it's end height.\n\t\t\taccordion_item.style.height = item_height_end + 'px';\n\t\t}\n\n\t} // End function: openItem.\n\n\t/**\n\t * Finish opening the accordion item.\n\t */\n\n\tstatic finishOpeningItem(accordion_item) {\n\t\t// Remove the open transitionend event listener.\n\t\taccordion_item.removeEventListener('transitionend', Accordion.headingOpenTransitionEndEventHandler);\n\t\t// Get the accordion element.\n\t\tconst accordion_parent = accordion_item.accordion_parent;\n\t\t// Remove the explicit height (should default back to auto).\n\t\taccordion_item.style.removeProperty('height');\n\t\t// Set the accordion item state attribute to show the item has finished opening.\n\t\taccordion_item.setAttribute(Accordion.item_state_attrubute, 'opened');\n\t}\n\n\t/**\n\t *\n\t */\n\n\tstatic closeItem(accordion_item, skip_transition) {\n\n\t\t// Remove the open transitionend event listener.\n\t\taccordion_item.removeEventListener('transitionend', Accordion.headingOpenTransitionEndEventHandler);\n\t\t// Get the accordion element.\n\t\tconst accordion_parent = accordion_item.accordion_parent;\n\t\t// Get the accordion options.\n\t\tconst accordion_options = accordion_parent.accordion_options;\n\t\t// Get the current item height.\n\t\tconst item_height_start = accordion_item.offsetHeight;\n\t\t// Set the item to its current height.\n\t\taccordion_item.style.height = item_height_start + 'px';\n\t\t// Set the accordion item state attribute to show the beginning of the closing process.\n\t\taccordion_item.setAttribute(Accordion.item_state_attrubute, 'closing');\n\t\t// Set the related aria attributes to show the accordion is closed.\n\t\taccordion_item.accordion_item_heading.setAttribute('aria-expanded', 'false');\n\t\taccordion_item.accordion_item_content.setAttribute('aria-hidden', 'true');\n\n\t\t// Skip transition is true.\n\t\tif(skip_transition) {\n\t\t\t// Finish closing the item immediately, disregarding transitions.\n\t\t\t// The passed argument must mimic the event listener event.\n\t\t\tAccordion.finishClosingItem(accordion_item);\n\t\t}\n\t\telse {\n\t\t\t// Get the height of the accordion heading.\n\t\t\tconst item_heading_height = accordion_item.accordion_item_heading.offsetHeight;\n\t\t\t// Add a close transitionend event listener to the accordion item.\n\t\t\taccordion_item.addEventListener('transitionend', Accordion.headingCloseTransitionEndEventHandler);\n\t\t\t// Set the accordion item to it's heading height.\n\t\t\taccordion_item.style.height = item_heading_height + 'px';\n\t\t}\n\n\t} // End function: closeItem.\n\n\t/**\n\t * Finish closing the accordion item.\n\t */\n\n\tstatic finishClosingItem(accordion_item) {\n\t\t// Remove the close transitionend event listener.\n\t\taccordion_item.removeEventListener('transitionend', Accordion.headingCloseTransitionEndEventHandler);\n\t\t// Get the accordion element.\n\t\tconst accordion_parent = accordion_item.accordion_parent;\n\t\t// Get the accordion options.\n\t\tconst accordion_options = accordion_parent.accordion_options;\n\t\t// Remove the explicit height (should default back to auto).\n\t\taccordion_item.style.removeProperty('height');\n\t\t// Set the accordion item state attribute to show the item has finished closing.\n\t\taccordion_item.setAttribute(Accordion.item_state_attrubute, 'closed');\n\n\t\t// If the close item children is true.\n\t\tif(accordion_options.close_nested_items === true) {\n\t\t\t// Get nested accordions.\n\t\t\tconst nested_accordions = accordion_item.querySelectorAll('[' + Accordion.id_attribute + ']');\n\t\t\t// For each nested accordion.\n\t\t\tfor(let nested_accordion = 0; nested_accordion < nested_accordions.length; nested_accordion++) {\n\t\t\t\t// Get this current nested accordion.\n\t\t\t\tconst this_nested_accordion = nested_accordions[nested_accordion];\n\t\t\t\t// Get this nested accordion parent accordion.\n\t\t\t\tconst this_nested_accordion_parent_accordion = this_nested_accordion.parentNode.closest('[' + Accordion.id_attribute + ']');\n\t\t\t\t// If the parent accordion matches the original item parent accordion. This ensures we only select accordions one level away.\n\t\t\t\tif(this_nested_accordion_parent_accordion === accordion_parent) {\n\t\t\t\t\t// For each item in the nested accordion.\n\t\t\t\t\tfor(let nested_item = 0; nested_item < this_nested_accordion.accordion_items.length; nested_item++) {\n\t\t\t\t\t\t// Get the current nested item.\n\t\t\t\t\t\tconst this_nested_item = this_nested_accordion.accordion_items[nested_item];\n\t\t\t\t\t\t// Close the nested item.\n\t\t\t\t\t\tAccordion.closeItem(this_nested_item, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // End option: close_nested_items.\n\n\t\t}\n\t}\n\n\t/**\n\t * Opens or closes an accordion item based on it's current state.\n\t */\n\n\tstatic toggleItem(accordion_item) {\n\t\t// Get the current accordion item state.\n\t\tconst accordion_item_state = accordion_item.getAttribute(Accordion.item_state_attrubute);\n\t\t// If the accordion item is currently closed.\n\t\tif(accordion_item_state === 'closed' || accordion_item_state === 'closing') {\n\t\t\t// Open the accordion item.\n\t\t\tAccordion.openItem(accordion_item);\n\t\t}\n\t\t// If the accordion is currently opening.\n\t\telse if(accordion_item_state === 'opening' || accordion_item_state === 'opened') {\n\t\t\t// Close the accordion item.\n\t\t\tAccordion.closeItem(accordion_item);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the user focus on a specific accordion item or the previous or next item within the accordion.\n\t */\n\n\tstatic focusItem(accordion_item, option) {\n\t\tlet item_to_focus = accordion_item;\n\t\tif(option) {\n\t\t\tconst accordion_items_list = accordion_item.accordion_parent.accordion_items;\n\t\t\tfor(let i = 0; i < accordion_items_list.length; i++) {\n\t\t\t\tif(accordion_items_list[i] === accordion_item) {\n\t\t\t\t\tif(option === 'previous' && i > 0) {\n\t\t\t\t\t\titem_to_focus = accordion_items_list[i - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if(option === 'next' && i < (accordion_items_list.length - 1)) {\n\t\t\t\t\t\titem_to_focus = accordion_items_list[i + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// console.log('There is no ' + option + ' item in this accordion.');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\titem_to_focus.accordion_item_heading.focus();\n\t}\n\n\t/**\n\t * Gets or sets the passed accordion and child accordion's aria level value.\n\t */\n\n\tstatic nestedLevel(accordion_element, nested_level) {\n\t\tconst accordion_data = accordion_element[Accordion.constants.data_property];\n\t\tif (nested_level) {\n\t\t\taccordion_data.nested_level = nested_level;\n\t\t\t// Get all accordion children elements.\n\t\t\tconst immediate_child_accordions = accordion_element.querySelectorAll('[' + Accordion.constants.id_attribute + ']');\n\t\t\t// For each child accordion.\n\t\t\tfor(let accordion_child = 0; accordion_child < accordion_children.length; accordion_child++) {\n\t\t\t\t// Get this current child accordion element.\n\t\t\t\tthis_accordion_child_element = accordion_children[accordion_child];\n\t\t\t\t// Get the current aria-level.\n\t\t\t\tconst current_aria_level = parseInt(this_aria_level_element.getAttribute('aria-level'));\n\t\t\t\t// Set a new aria-level one greater than before.\n\t\t\t\tthis_aria_level_element.setAttribute('aria-level', (current_aria_level + 1));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn accordion_element[Accordion.constants.data_property].nested_level;\n\t\t}\n\t}\n\n\t/**\n\t * Initializes an accordion.\n\t *\n\t * @param {object} options - The merged options used to configure the accordion.\n\t */\n\n\tinitialize_old(options) {\n\n\t\tlet this_accordion_element,\n\t\tthis_accordion_data,\n\t\taccordions_existing,\n\t\taccordion_next_id,\n\t\taccordion_nested_level,\n\t\taccordion_parent,\n\t\taccordion_children,\n\t\tthis_accordion_child_element;\n\n\t\t// Get the accordion element(s).\n\t\tconst accordion_elements = document.querySelectorAll(options.selectors.accordion);\n\n\t\t// For each accordion.\n\t\tfor(let accordion_element = 0; accordion_element < accordion_elements.length; accordion_element++) {\n\n\t\t\t// Get this current accordion element for the loop.\n\t\t\tthis_accordion_element = accordion_elements[accordion_element];\n\t\t\t// Initialize the accordion data object on the element.\n\t\t\tthis_accordion_element[Accordion.constants.data_property] = {};\n\t\t\t// Define a shortcut to this accordion's data, for code clarity.\n\t\t\tthis_accordion_data = this_accordion_element[Accordion.constants.data_property];\n\t\t\t\n\t\t\t// Attach the accordion element to the accordion data.\n\t\t\tthis_accordion_data.element = this_accordion_element;\n\n\t\t\t// Attach the accordion options to the accordion data.\n\t\t\tthis_accordion_data.options = options;\n\n\t\t\t// Get the existing accordions.\n\t\t\taccordions_existing = document.querySelectorAll('[' + Accordion.constants.id_attribute + ']');\n\t\t\t// Generate the next accordion id.\n\t\t\taccordion_next_id = accordions_existing.length + 1;\n\t\t\twhile (document.querySelector('[' + Accordion.constants.id_attribute + ']=\"' + thing + '\"')) {\n\t\t\t\tthing++;\n\t\t\t}\n\n\t\t\t// Set the accordion id data attribute.\n\t\t\tthis_accordion_element.setAttribute(Accordion.constants.id_attribute, accordion_next_id);\n\t\t\t// Set this accordion selector by accordion id attribute.\n\t\t\tthis_accordion_data.unique_selector = '[' + Accordion.constants.id_attribute + '=\"' + accordion_next_id + '\"]';\n\n\t\t\t//\n\t\t\t// Item\n\t\t\t//\n\n\t\t\t// Get accordion items.\n\t\t\tconst accordion_items = this_accordion_element.querySelectorAll(this_accordion_data.selector + ' > ' + options.selectors.item);\n\t\t\t// Attach the accordion items to the accordion element.\n\t\t\tthis_accordion_element.accordion_items = accordion_items;\n\t\t\t// For each accordion item.\n\t\t\tfor(let accordion_item = 0; accordion_item < accordion_items.length; accordion_item++) {\n\t\t\t\t// Get this current item element in the accordion.\n\t\t\t\tconst this_accordion_item = accordion_items[accordion_item];\n\t\t\t\t// Attach the accordion parent to the accordion item element.\n\t\t\t\tthis_accordion_item.accordion_parent = this_accordion_element;\n\t\t\t\t// Initialize item state values.\n\t\t\t\tlet item_state_attrubute_value = 'closed';\n\t\t\t\tlet aria_hidden_value = 'true';\n\t\t\t\tlet aria_expanded_value = 'false';\n\t\t\t\t// If this is the first accordion item and the first item default open option is set to true.\n\t\t\t\tif(accordion_item === 0 && options.first_item_default_open) {\n\t\t\t\t\t// Set the state values as open for the accordion item.\n\t\t\t\t\titem_state_attrubute_value = 'opened';\n\t\t\t\t\taria_hidden_value = 'false';\n\t\t\t\t\taria_expanded_value = 'true';\n\t\t\t\t}\n\t\t\t\t// Set the item state.\n\t\t\t\tthis_accordion_item.setAttribute(Accordion.item_state_attrubute, item_state_attrubute_value);\n\n\t\t\t\t//\n\t\t\t\t// Content\n\t\t\t\t//\n\n\t\t\t\t// Get accordion item content.\n\t\t\t\tconst accordion_item_content = this_accordion_item.querySelector(options.selectors.content);\n\t\t\t\t// Attach the accordion item content to the accordion item element.\n\t\t\t\tthis_accordion_item.accordion_item_content = accordion_item_content;\n\t\t\t\t// Attach the accordion parent to the accordion item content element.\n\t\t\t\taccordion_item_content.accordion_parent = this_accordion_element;\n\t\t\t\t// Attach the accordion item parent to the accordion item content element.\n\t\t\t\taccordion_item_content.accordion_item_parent = this_accordion_item;\n\t\t\t\t// Get the next available accordion id.\n\t\t\t\tconst accordion_item_content_uuid = uuid();\n\t\t\t\t// Set the accordion item content id.\n\t\t\t\taccordion_item_content.id = accordion_item_content_uuid;\n\t\t\t\t// Set the accordion item content aria-hidden attribute.\n\t\t\t\taccordion_item_content.setAttribute('aria-hidden', aria_hidden_value);\n\n\t\t\t\t//\n\t\t\t\t// Heading\n\t\t\t\t//\n\n\t\t\t\t// Get accordion item heading.\n\t\t\t\tconst accordion_item_heading = this_accordion_item.querySelector(options.selectors.heading);\n\t\t\t\t// Attach the accordion item heading to the accordion item element.\n\t\t\t\tthis_accordion_item.accordion_item_heading = accordion_item_heading;\n\t\t\t\t// Attach the accordion parent to the accordion item heading element.\n\t\t\t\taccordion_item_heading.accordion_parent = this_accordion_element;\n\t\t\t\t// Attach the accordion item parent to the accordion item heading element.\n\t\t\t\taccordion_item_heading.accordion_item_parent = this_accordion_item;\n\t\t\t\t// Set the accordion item heading role attribute.\n\t\t\t\taccordion_item_heading.setAttribute('role', 'heading');\n\t\t\t\t// Set the accordion item heading aria-controls attribute to the accordion item content id.\n\t\t\t\taccordion_item_heading.setAttribute('aria-controls', accordion_item_content.id);\n\t\t\t\t// Set the accordion item heading aria-level attribute.\n\t\t\t\taccordion_item_heading.setAttribute('aria-level', accordion_level);\n\t\t\t\t// Set the accordion item heading aria-expanded attribute.\n\t\t\t\taccordion_item_heading.setAttribute('aria-expanded', aria_expanded_value);\n\t\t\t\t// Add click event listener to toggle the accordion item opened/closed state.\n\t\t\t\taccordion_item_heading.addEventListener('click', Accordion.headingClickEventHandler);\n\t\t\t\t// Add key down event listener for switching between accordion items and accessibility.\n\t\t\t\taccordion_item_heading.addEventListener('keydown', Accordion.headingKeyDownEventHandler);\n\n\t\t\t} // End loop: accordion_items.\n\n\t\t\t// Set the accordion aria-label attribute.\n\t\t\tthis_accordion_element.setAttribute('aria-label', this_accordion_data.options.aria_label);\n\n\t\t\t// Get the closest parent accordion.\n\t\t\t// Closest must be called on the parent node to prevent it from returning the node it's being called form.\n\t\t\taccordion_parent = this_accordion_element.parentNode.closest('[' + Accordion.constants.id_attribute + ']');\n\t\t\t// If a parent accordion exists.\n\t\t\tif(accordion_parent) {\n\t\t\t\t// Add one to the parent aria-level for the current accordion aria-level.\n\t\t\t\taccordion_nested_level = Accordion.nestedLevel(accordion_parent) + 1;\n\t\t\t}\n\t\t\t// If there is no parent accordion (the accordion is not nested in another accordion).\n\t\t\telse {\n\t\t\t\t// Set the accordion aria-level attribute value.\n\t\t\t\taccordion_nested_level = 1;\n\t\t\t}\n\t\t\t// Set this accordion and nested accordion's nested level.\n\t\t\tAccordion.nestedLevel(this_accordion_element, accordion_nested_level);\n\n\t\t\t// Get all accordion children elements.\n\t\t\taccordion_children = this_accordion_element.querySelectorAll('[' + Accordion.constants.id_attribute + ']');\n\t\t\t// For each child accordion.\n\t\t\tfor(let accordion_child = 0; accordion_child < accordion_children.length; accordion_child++) {\n\t\t\t\t// Get this current child accordion element.\n\t\t\t\tthis_accordion_child_element = accordion_children[accordion_child];\n\t\t\t\t// Get the current aria-level.\n\t\t\t\tconst current_aria_level = parseInt(this_aria_level_element.getAttribute('aria-level'));\n\t\t\t\t// Set a new aria-level one greater than before.\n\t\t\t\tthis_aria_level_element.setAttribute('aria-level', (current_aria_level + 1));\n\t\t\t}\n\n\t\t} // End loop accordion_elements.\n\n\t} // End function: initialize.\n}; // End class: AceAccordion\n\n// If script is being required as a node module.\nif (typeof module !== 'undefined' && module.exports) {\n\t// Export the AceAccordion class.\n\tmodule.exports = AceAccordion;\n}\n\n\n//# sourceURL=webpack://AceAccordion/./src/js/ace-accordion.js?");

/***/ }),

/***/ "./src/js/content.js":
/*!***************************!*\
  !*** ./src/js/content.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Defines a Content.\n */\n\nconst Content = class {\n\n\t/**\n\t *\n\t */\n\n\tget options() {\n\t\t// Return options from the wrapper AceAccordion object.\n\t\treturn this.wrapper_item.wrapper_accordion.wrapper_ace_accordion.options;\n\t} // End method: get options\n\n\t/**\n\t *\n\t */\n\n\tgenerateId() {\n\t\t// Generate a unique id based off wrapper instance ids.\n\t\treturn 'accordion-content-' + this.wrapper_item.wrapper_accordion.wrapper_ace_accordion.id + '-' + this.wrapper_item.wrapper_accordion.id + '-' + this.wrapper_item.id;\n\t} // End method: generateId\n\n\t/**\n\t *\n\t */\n\n\tconstructor(item, content_element) {\n\n\t\t// Set references to the wrapper instances.\n\t\tthis.wrapper_item = item;\n\n\t\t// Add the content element reference.\n\t\tthis.element = content_element;\n\n\t\t// Add the this instance object reference to the element.\n\t\tthis.element.ace_object = this;\n\n\t\t// If the element does not have an id.\n\t\tif (this.element.id === '') {\n\t\t\t// Generate and set a unique id.\n\t\t\tthis.element.id = this.generateId();\n\t\t}\n\n\t\t// Set the aria expanded value to false.\n\t\tlet aria_hidden_value = true;\n\t\t// If the wrapper item is opened.\n\t\tif (this.wrapper_item.state === 'opened') {\n\t\t\t// Set the aria expanded value equal to true.\n\t\t\taria_hidden_value = false;\n\t\t}\n\t\t// Set the heading aria-expanded attribute.\n\t\tthis.element.setAttribute('aria-hidden', aria_hidden_value);\n\n\t\t// Return this instance.\n\t\treturn this;\n\n\t} // End method: constructor\n\n}; // End class: Content\n\n// Export the Content class.\nmodule.exports = Content;\n\n//# sourceURL=webpack://AceAccordion/./src/js/content.js?");

/***/ }),

/***/ "./src/js/heading.js":
/*!***************************!*\
  !*** ./src/js/heading.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Defines a Heading.\n */\n\nconst Heading = class {\n\n\t/**\n\t *\n\t */\n\n\tget options() {\n\t\t// Return options from the wrapper AceAccordion object.\n\t\treturn this.wrapper_item.wrapper_accordion.wrapper_ace_accordion.options;\n\t} // End method: get options\n\n\t/**\n\t *\n\t */\n\n\tconstructor(item, heading_element) {\n\n\t\t// Set references to the wrapper instances.\n\t\tthis.wrapper_item = item;\n\n\t\t// Add the heading element reference.\n\t\tthis.element = heading_element;\n\n\t\t// Add the this instance object reference to the element.\n\t\tthis.element.ace_object = this;\n\n\t\t// Set the heading role attribute to heading.\n\t\tthis.element.setAttribute('role', 'heading');\n\t\t// Set the heading aria-controls attribute to the item content id.\n\t\tthis.element.setAttribute('aria-controls', this.wrapper_item.content.element.id);\n\t\t// Set the heading aria-level attribute.\n\t\tthis.element.setAttribute('aria-level', this.wrapper_item.wrapper_accordion.nested_level);\n\t\t// Set the aria expanded value to false.\n\t\tlet aria_expanded_value = false;\n\t\t// If the wrapper item is opened.\n\t\tif (this.wrapper_item.state === 'opened') {\n\t\t\t// Set the aria expanded value equal to true.\n\t\t\taria_expanded_value = true;\n\t\t}\n\t\t// Set the heading aria-expanded attribute.\n\t\tthis.element.setAttribute('aria-expanded', aria_expanded_value);\n\n\t\t// Return this instance.\n\t\treturn this;\n\n\t} // End method: constructor\n\n}; // End class: Heading\n\n// Export the Heading class.\nmodule.exports = Heading;\n\n//# sourceURL=webpack://AceAccordion/./src/js/heading.js?");

/***/ }),

/***/ "./src/js/item.js":
/*!************************!*\
  !*** ./src/js/item.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Require Heading class.\nconst Heading = __webpack_require__(/*! ./heading.js */ \"./src/js/heading.js\");\n// Require Content class.\nconst Content = __webpack_require__(/*! ./content.js */ \"./src/js/content.js\");\n\n\n/**\n * Defines an Item.\n */\n\nconst Item = class {\n\n\t/**\n\t * Defines constant class variables.\n\t */\n\n\tstatic get constants() {\n\t\treturn {\n\t\t\tcount_property: 'item_count',\n\t\t\tinstances_property: 'items',\n\t\t\tid_attribute: 'data-item-id',\n\t\t\tstate_attrubute: 'data-item-state',\n\t\t\tstates: [\n\t\t\t\t'opening',\n\t\t\t\t'opened',\n\t\t\t\t'closing',\n\t\t\t\t'closed'\n\t\t\t]\n\t\t};\n\t} // End method: static get constants\n\n\t/**\n\t *\n\t */\n\n\tget options() {\n\t\t// Return options from the wrapper AceAccordion object.\n\t\treturn this.wrapper_accordion.wrapper_ace_accordion.options;\n\t} // End method: get options\n\n\t/**\n\t *\n\t */\n\n\tget index() {\n\t\t// Get the items elements from the wrapper accordion.\n\t\tconst items = this.wrapper_accordion.item_elements;\n\t\t// Return the index of this item in the list of items.\n\t\treturn items.indexOf(this.element);\n\t} // End method: get index\n\n\t/**\n\t *\n\t */\n\n\tget state() {\n\t\t// Returns null if attribute is not set.\n\t\treturn this.element.getAttribute(this.constructor.constants.state_attrubute);\n\t} // End method: get state\n\n\t/**\n\t *\n\t */\n\n\tset state(state) {\n\t\t// If the passed value is a valid state.\n\t\tif (this.constructor.constants.states.indexOf(state) >= 0) {\n\t\t\t// Set the item state attribute equal to the passed state.\n\t\t\tthis.element.setAttribute(this.constructor.constants.state_attrubute, state);\n\t\t\t// Return the state value.\n\t\t\treturn state;\n\t\t}\n\t\t// If the passed value is not a valid state.\n\t\telse {\n\t\t\tconsole.warn('invalid state, options are: ' + this.constructor.constants.states);\n\t\t\treturn false;\n\t\t}\n\t} // End method: set state\n\n\t/**\n\t *\n\t */\n\n\taddInstance() {\n\t\t// Call the static function to add the instance and return the instance id.\n\t\tconst instance_id = this.wrapper_accordion.wrapper_ace_accordion.constructor.addInstance({\n\t\t\tinstance: this, // The instance to add.\n\t\t\tclass_reference: this.wrapper_accordion, // The class to add the instance to.\n\t\t\tcount_property: this.constructor.constants.count_property, // The count property on the class.\n\t\t\tlist_property: this.constructor.constants.instances_property // The instance list property on the class.\n\t\t});\n\t\t// Return the instance id.\n\t\treturn instance_id;\n\t} // End method: addInstance\n\n\t/**\n\t * Check if this item matches the criteria.\n\t */\n\n\tmatches(criteria) {\n\n\t\t// If the criteria is a node list.\n\t\tif (criteria instanceof NodeList) {\n\t\t\t// Convert the criteria into an array.\n\t\t\tcriteria = Array.from(criteria);\n\t\t}\n\n\t\t// If the criteria is an array.\n\t\tif (Array.isArray(criteria)) {\n\t\t\t// For each value in the criteria array.\n\t\t\tfor (let value = 0; value < criteria.length; value++) {\n\t\t\t\t// If the recursive call matches the criteria to the item.\n\t\t\t\tif (this.matches(criteria[value])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If the criteria is a number (index).\n\t\telse if (typeof criteria === 'number') {\n\t\t\t// If the criteria is an integer.\n\t\t\tif (Number.isInteger(criteria)) {\n\t\t\t\t// If the criteria is greater than or equal to zero.\n\t\t\t\tif (criteria >= 0) {\n\t\t\t\t\t// If the item matches the criteria index.\n\t\t\t\t\tif (this.index === criteria) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If the criteria is a string (selector).\n\t\telse if (typeof criteria === 'string') {\n\t\t\t// If the item matches the criteria selector.\n\t\t\tif (this.element.matches(criteria)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// If the criteria is an element.\n\t\telse if (criteria instanceof Element) {\n\t\t\t// If the item matches the criteria element.\n\t\t\tif (this.element === criteria) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// If the item does not match the criteria.\n\t\treturn false;\n\n\t} // End method: matches\n\n\t/**\n\t *\n\t */\n\n\tinitializeHeading(heading_element) {\n\t\t//\n\t} // End method: initializeHeading\n\n\t/**\n\t *\n\t */\n\n\tconstructor(accordion, item_element) {\n\n\t\t// Set a reference to the wrapper instance.\n\t\tthis.wrapper_accordion = accordion;\n\n\t\t// Add the item element reference.\n\t\tthis.element = item_element;\n\n\t\t// Add the this instance object reference to the element.\n\t\tthis.element.ace_object = this;\n\n\t\t// Add this instance to the wrapper instance and set the instance id.\n\t\tthis.id = this.addInstance();\n\n\t\t// Set the Accordion class instance id data attribute.\n\t\tthis.element.setAttribute(this.constructor.constants.id_attribute, this.id);\n\n\t\t// Create a unique selector for this item.\n\t\tthis.selector = this.wrapper_accordion.selector + ' > [' + this.constructor.constants.id_attribute + '=\"' + this.id + '\"]';\n\n\t\t// Initialize the item state.\n\t\tlet initial_state = 'closed';\n\t\t// If the default_open_items option value is not false, null, or undefined.\n\t\tif (this.options.default_open_items !== false ||\n\t\t\tthis.options.default_open_items !== null ||\n\t\t\ttypeof this.options.default_open_items !== 'undefined') {\n\t\t\t// If the element matches the default_open_items value.\n\t\t\tif (this.matches(this.options.default_open_items)) {\n\t\t\t\t// Set the item state value to opened.\n\t\t\t\tinitial_state = 'opened';\n\t\t\t}\n\t\t}\n\t\t// Set the item state.\n\t\tthis.state = initial_state;\n\n\t\t// Get the content element.\n\t\tconst content_element = this.element.querySelector(this.selector + ' > ' + this.options.selectors.content);\n\t\tthis.content = new Content(this, content_element);\n\n\t\t// Get the heading element.\n\t\tconst heading_element = this.element.querySelector(this.selector + ' > ' + this.options.selectors.heading);\n\t\tthis.heading = new Heading(this, heading_element);\n\n\t\t// Return this instance.\n\t\treturn this;\n\n\t} // End method: constructor\n\n}; // End class: Item\n\n// Export the Item class.\nmodule.exports = Item;\n\n//# sourceURL=webpack://AceAccordion/./src/js/item.js?");

/***/ })

/******/ });